{"version":3,"file":"bundle.js","mappings":"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","sources":["webpack://desmoscript/webpack/bootstrap","webpack://desmoscript/webpack/runtime/define property getters","webpack://desmoscript/webpack/runtime/hasOwnProperty shorthand","webpack://desmoscript/webpack/runtime/make namespace object","webpack://desmoscript/./src/debug/debug.ts","webpack://desmoscript/./src/compiler-errors.ts","webpack://desmoscript/./src/parse/lex.ts","webpack://desmoscript/./src/ast/ast.ts","webpack://desmoscript/./src/parse/parse.ts","webpack://desmoscript/./src/ast/fmt.ts","webpack://desmoscript/./src/scope-tree/create-scope-tree.ts","webpack://desmoscript/./src/scope-tree/typecheck/type-errors.ts","webpack://desmoscript/./src/scope-tree/typecheck/typecheck-binop.ts","webpack://desmoscript/./src/macro/macro-api.ts","webpack://desmoscript/./src/stdlib/stdlib.ts","webpack://desmoscript/./node_modules/zod/lib/index.mjs","webpack://desmoscript/./src/scope-tree/typecheck/typecheck-builtin-fn.ts","webpack://desmoscript/./src/scope-tree/typecheck/typecheck.ts","webpack://desmoscript/./src/codegen/graphstate.ts","webpack://desmoscript/./src/codegen/codegen.ts","webpack://desmoscript/./src/scope-tree/resolve-imports.ts","webpack://desmoscript/./src/macro/instantiate-macros.ts","webpack://desmoscript/./src/combined-functionality/full-compiler.ts","webpack://desmoscript/./src/combined-functionality/language-support-compiler.ts","webpack://desmoscript/./src/ast/compare-ast.ts","webpack://desmoscript/./src/index.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","export let DESMO_DEBUG = false;\nexport function enableDebug() {\n    DESMO_DEBUG = true;\n}\nexport function debugPrint(...args) {\n    if (DESMO_DEBUG)\n        console.log(...args);\n}\nexport function debugTrace() {\n    if (DESMO_DEBUG)\n        console.trace();\n}\n","import { debugTrace } from \"./debug/debug\";\nexport function compilerError(reason, start, end, unit) {\n    return { reason, start, end, type: \"general\", unit };\n}\nexport function ok(data) {\n    return { success: true, data };\n}\nexport function err(data) {\n    return { success: false, data };\n}\nexport function internalError(reason) {\n    return { reason, internal: true };\n}\nexport function assertNotUndefined(t, customErrorMessage) {\n    if (t == undefined) {\n        debugTrace();\n        throw internalError(customErrorMessage ?? \"unexpected undefined\");\n    }\n    return t;\n}\n","import { compilerError, } from \"../compiler-errors\";\nexport function token(start, end, str, type) {\n    return { start, end, str, type };\n}\nexport function streamify(str) {\n    let pos = 0;\n    return {\n        done: () => pos >= str.length,\n        pos: () => pos,\n        match: (pattern, noConsume) => {\n            if (Array.isArray(pattern)) {\n                for (const p of pattern) {\n                    if (str.slice(pos).startsWith(p)) {\n                        if (!noConsume)\n                            pos += p.length;\n                        return p;\n                    }\n                }\n            }\n            else if (pattern instanceof RegExp) {\n                const match = str.slice(pos).match(pattern)?.[0];\n                if (match) {\n                    if (!noConsume)\n                        pos += match.length;\n                    return match;\n                }\n            }\n            else if (pattern instanceof Function) {\n                const count = pattern(str.slice(pos));\n                const match = str.slice(pos, pos + count);\n                if (!noConsume)\n                    pos += count;\n                return match;\n            }\n            else {\n                if (str.slice(pos).startsWith(pattern)) {\n                    if (!noConsume)\n                        pos += pattern.length;\n                    return pattern;\n                }\n            }\n        },\n        next: (x) => {\n            pos += x;\n            return str.slice(pos - x, pos);\n        },\n        rest: () => str.slice(pos),\n    };\n}\nexport function lex(input, filename, errors) {\n    const stream = streamify(input);\n    const syntaxErrors = [];\n    const tokens = [];\n    const appendMatch = (match, type) => tokens.push(token(stream.pos() - match.length, stream.pos(), match, type));\n    while (!stream.done()) {\n        // match two consecutive line breaks\n        // included for formatting purposes\n        const linebreaks = stream.match(/^\\s*\\n\\s*\\n\\s*/);\n        if (linebreaks) {\n            appendMatch(linebreaks, \"whitespace\");\n            continue;\n        }\n        // match whitespace\n        const ws = stream.match(/^\\s+/);\n        if (ws) {\n            //appendMatch(ws, \"whitespace\");\n            continue;\n        }\n        // match strings/notes\n        const note = stream.match(/^\"[^\"]*\"/);\n        if (note) {\n            appendMatch(note, \"note\");\n            continue;\n        }\n        // match misc symbols\n        const symbol = stream.match([\";\", \":\", \",\", \"..\", \"@\"]);\n        if (symbol) {\n            appendMatch(symbol);\n            continue;\n        }\n        // match brackets\n        const bracket = stream.match([\"(\", \")\", \"[\", \"]\", \"{\", \"}\"]);\n        if (bracket) {\n            appendMatch(bracket);\n            continue;\n        }\n        // match numbers\n        let num = stream.match(/^[0-9]*\\.[0-9]+/);\n        // match integers\n        // but don't match the period if there's two of them afterwards\n        // because that represents a range\n        if (!num)\n            num = stream.match(/^[0-9]+(\\.(?!\\.))?/);\n        if (num) {\n            appendMatch(num, \"number\");\n            continue;\n        }\n        // match operators\n        const op = stream.match([\n            \"+\",\n            \"-\",\n            \"*\",\n            \"/\",\n            \">=\",\n            \"<=\",\n            \">\",\n            \"<\",\n            \"==\",\n            \"!\",\n            \"^\",\n            \"->\",\n            \".x\",\n            \".y\",\n            \".\",\n            \"=\",\n        ]);\n        if (op) {\n            appendMatch(op, \"op\");\n            continue;\n        }\n        // match identifiers\n        const ident = stream.match(/^\\w+/);\n        if (ident) {\n            appendMatch(ident, \"ident\");\n            continue;\n        }\n        // unrecognized input; syntax error\n        const offendingText = stream.next(1);\n        errors.push(compilerError(`did not expect '${offendingText}'`, stream.pos() - 1, stream.pos(), filename));\n    }\n    return tokens;\n}\n","import { err, ok } from \"../compiler-errors\";\nexport function errnode(reason, start, end) {\n    return {\n        type: \"error\",\n        reason,\n        start,\n        end,\n    };\n}\nlet idCounter = 0;\nexport function newid() {\n    return ++idCounter;\n}\nexport function asExpr(node) {\n    const t = node.type;\n    if (t == \"number\" ||\n        t == \"point\" ||\n        t == \"list\" ||\n        t == \"block\" ||\n        t == \"identifier\" ||\n        t == \"fncall\" ||\n        t == \"binop\" ||\n        t == \"unop\" ||\n        t == \"range\" ||\n        t == \"listcomp\" ||\n        t == \"match\" ||\n        t == \"note\" ||\n        t == \"macrocall\") {\n        return ok(node);\n    }\n    return err(undefined);\n}\nexport function writeASTDebug(n, indent) {\n    if (!indent)\n        indent = 0;\n    if (typeof n == \"string\")\n        return `\"${n}\"`;\n    if (Array.isArray(n))\n        return `[${n\n            .map((e) => writeASTDebug(e, indent + 2))\n            .join(\" \")}]`;\n    if (typeof n == \"object\" && typeof n.id == \"number\") {\n        const node = n;\n        switch (node.type) {\n            case \"number\":\n                return node.number.toString();\n            case \"note\":\n                return `\"${node.content}\"`;\n            default:\n                const strs = [\"\"];\n                for (const [k, v] of Object.entries(node)) {\n                    if (k == \"start\")\n                        continue;\n                    if (k == \"id\")\n                        continue;\n                    if (k == \"end\")\n                        continue;\n                    if (k == \"type\")\n                        continue;\n                    strs.push(`${k}=${writeASTDebug(v, indent + 2)}`);\n                }\n                strs.push(\"\");\n                return `(${node.type} ${strs.join(\"\\n\" + \"\".padStart(indent, \" \"))})`;\n        }\n    }\n    return n?.toString() ?? \"undefined\";\n}\nexport function getErrors(ast) {\n    if (Array.isArray(ast))\n        return ast.map((e) => getErrors(e)).flat();\n    if (typeof ast == \"object\") {\n        if (ast.type == \"error\") {\n            return [ast];\n        }\n        else {\n            return getErrors(Object.values(ast));\n        }\n    }\n    return [];\n}\nexport function deduplicateErrors(errors) {\n    const uniqueErrors = [];\n    for (const e1 of errors) {\n        let unique = true;\n        for (const e2 of uniqueErrors) {\n            if (e1.start == e2.start && e1.reason == e2.reason && e1.end == e2.end) {\n                unique = false;\n                break;\n            }\n        }\n        if (unique) {\n            uniqueErrors.push(e1);\n        }\n    }\n    return uniqueErrors;\n}\nexport function forEachAST(node, ctx, mapper) {\n    function map(n, myctx) {\n        //@ts-ignore\n        if (Array.isArray(n))\n            return n.map((e) => map(e, myctx));\n        //@ts-ignore\n        if (n && typeof n == \"object\" && typeof n.id == \"number\") {\n            const node = n;\n            //@ts-ignore\n            const innerctx = mapper(node, myctx);\n            //@ts-ignore\n            Object.entries(node).forEach(([k, v]) => [k, map(v, innerctx)]);\n        }\n    }\n    map(node, ctx);\n}\nexport async function forEachASTAsync(node, ctx, mapper) {\n    async function map(n, myctx) {\n        //@ts-ignore\n        if (Array.isArray(n))\n            return await Promise.all(n.map((e) => map(e, myctx)));\n        //@ts-ignore\n        if (n && typeof n == \"object\" && typeof n.id == \"number\") {\n            const node = n;\n            //@ts-ignore\n            const innerctx = await mapper(node, myctx);\n            //@ts-ignore\n            await Promise.all(Object.entries(node).map(([k, v]) => map(v, innerctx)));\n        }\n    }\n    await map(node, ctx);\n}\n","import { asExpr, newid, errnode, getErrors, } from \"../ast/ast\";\nexport function tokenStreamify(tokens) {\n    let pos = 0;\n    return {\n        next: (considerWhitespace) => {\n            if (pos >= tokens.length)\n                return undefined;\n            if (!considerWhitespace)\n                while (tokens[pos] && tokens[pos].type == \"whitespace\")\n                    pos++;\n            pos++;\n            return tokens[pos - 1];\n        },\n        peek: (considerWhitespace) => {\n            let pos2 = pos;\n            if (!considerWhitespace)\n                while (tokens[pos2] && tokens[pos2].type == \"whitespace\")\n                    pos2++;\n            return tokens[pos2];\n        },\n        done: (considerWhitespace) => {\n            let pos2 = pos;\n            while (pos2 < tokens.length) {\n                if (tokens[pos2].type != \"whitespace\" || considerWhitespace)\n                    return false;\n                pos2++;\n            }\n            return true;\n        },\n        prev: (considerWhitespace) => {\n            if (considerWhitespace) {\n                pos--;\n                return;\n            }\n            do {\n                pos--;\n            } while (tokens[pos].type != \"whitespace\");\n        },\n        prevPeek: (considerWhitespace) => {\n            let pos2 = pos;\n            if (considerWhitespace) {\n                pos2--;\n                return tokens[pos2];\n            }\n            do {\n                pos2--;\n            } while (tokens[pos2].type == \"whitespace\");\n            return tokens[pos2];\n        },\n        stringpos: () => tokens[pos]?.start ?? tokens[tokens.length - 1].start ?? 0,\n        stringposend: (offset, considerWhitespace) => {\n            let remainingOffset = Math.abs(offset ?? 0);\n            let offsetSign = Math.sign(offset ?? 0);\n            let posOffset = 0;\n            while (remainingOffset > 0) {\n                posOffset += offsetSign;\n                if (tokens[pos + posOffset]?.type != \"whitespace\" || considerWhitespace)\n                    remainingOffset--;\n            }\n            return tokens[pos + posOffset]?.end ?? tokens[tokens.length - 1].end ?? 0;\n        },\n        getpos: () => pos,\n        setpos: (n) => (pos = n),\n    };\n}\nexport function parse(tokens, unitName, errors, highlights) {\n    const tokenStream = tokenStreamify(tokens);\n    const encounteredTokenErrors = new Set();\n    const nodeAssembler = (nodefn, restartOnFailure) => {\n        const start = tokenStream.stringpos();\n        const oldpos = tokenStream.getpos();\n        try {\n            const rawNode = nodefn({\n                expectToken(str, err, endOfInputErr) {\n                    const token = tokenStream.next();\n                    if (!token)\n                        throw errnode(endOfInputErr ??\n                            `unexpected end of input: ${err}` ??\n                            `unexpected end of input: expected '${str}'`, tokenStream.stringpos(), tokenStream.stringpos());\n                    if (token.str != str)\n                        throw errnode(err ?? `expected '${str}', got '${token.str}'`, tokenStream.stringpos() - token.str.length - 1, tokenStream.stringpos());\n                },\n                expectOneOfTheseTokens(strs, err, endOfInputErr) {\n                    const token = tokenStream.next();\n                    if (!token)\n                        throw errnode(endOfInputErr ??\n                            `unexpected end of input: ${err}` ??\n                            `unexpected end of input: expected one of ${strs\n                                .map((s) => `'${s}'`)\n                                .join(\", \")}`, tokenStream.stringpos(), tokenStream.stringpos());\n                    for (const str of strs) {\n                        if (token.str == str)\n                            return token;\n                    }\n                    throw errnode(err ??\n                        `expected one of ${strs.map((s) => `'${s}'`).join(\", \")}, got '${token.str}'`, tokenStream.stringpos() - token.str.length, tokenStream.stringpos());\n                },\n                expectTokenType(type, err, endOfInputErr) {\n                    const token = tokenStream.next();\n                    if (!token) {\n                        throw errnode(endOfInputErr ??\n                            `unexpected end of input: ${err}` ??\n                            `unexpected end of input: expected a/an '${type}' token`, tokenStream.stringpos(), tokenStream.stringpos());\n                    }\n                    if (token.type != type)\n                        throw errnode(err ??\n                            `expected a '${type}' token; got '${token.str}' a '${token.type}' token`, tokenStream.stringpos() - token.str.length, tokenStream.stringpos());\n                    return token;\n                },\n                expectExpression(bindingPower) {\n                    return parseExpr(ctx, bindingPower ?? 0);\n                },\n                expectJson(isTopLevel) {\n                    return parseJson(ctx, isTopLevel);\n                },\n                isNextToken(str) {\n                    const token = tokenStream.peek();\n                    return token?.str == str;\n                },\n                isNextTokenType(str) {\n                    const token = tokenStream.peek();\n                    return token?.type == str;\n                },\n                consumeTokenIfExists(str) {\n                    const token = tokenStream.peek();\n                    if (token?.str == str) {\n                        tokenStream.next();\n                        return true;\n                    }\n                    return false;\n                },\n                expectExpressionOrStatement(err, endOfInputErr) {\n                    let oldpos = tokenStream.getpos();\n                    let node = parseStatement(ctx);\n                    if (node.type != \"error\")\n                        return node;\n                    tokenStream.setpos(oldpos);\n                    return parseExpr(ctx, 0);\n                },\n                expectAny() {\n                    let oldpos = tokenStream.getpos();\n                    let node = parseStatement(ctx);\n                    if (node.type != \"error\")\n                        return node;\n                    tokenStream.setpos(oldpos);\n                    let json = parseJson(ctx);\n                    if (node.type != \"error\")\n                        return node;\n                    tokenStream.setpos(oldpos);\n                    return parseExpr(ctx, 0);\n                },\n                error(message) {\n                    return errnode(message);\n                },\n                tokenError(message) {\n                    let start = tokenStream.stringpos();\n                    let end = tokenStream.stringposend();\n                    if (encounteredTokenErrors.has(start)) {\n                        tokenStream.next();\n                    }\n                    encounteredTokenErrors.add(start);\n                    return {\n                        ...errnode(message),\n                        id: newid(),\n                        start,\n                        end,\n                    };\n                },\n                peek(considerWhitespace) {\n                    let token = tokenStream.peek(considerWhitespace);\n                    if (!token)\n                        throw errnode(\"unexpected end of input\");\n                    return token;\n                },\n                maybeNext(considerWhitespace) {\n                    return tokenStream.next(considerWhitespace);\n                },\n                maybePeek() {\n                    return tokenStream.peek();\n                },\n                isEnd() {\n                    return tokenStream.done();\n                },\n                getpos() {\n                    return tokenStream.getpos();\n                },\n                setpos(n) {\n                    tokenStream.setpos(n);\n                },\n                markNoReturn() {\n                    restartOnFailure = false;\n                },\n                highlightLastToken: (highlight) => {\n                    const lastToken = tokenStream.prevPeek();\n                    if (!lastToken)\n                        throw errnode(\"cannot highlight undefined\");\n                    highlights?.push({\n                        start: lastToken.start,\n                        end: lastToken.end,\n                        type: highlight,\n                    });\n                },\n                softError: (reason, start, end) => {\n                    errors.push({ reason, start, end, type: \"general\", unit: unitName });\n                },\n                clearErrorsFrom: (start, end) => {\n                    for (let i = 0; i < errors.length; i++) {\n                        if (start > errors[i].start || end < errors[i].end) {\n                            errors.splice(i, 1);\n                            i--;\n                        }\n                    }\n                },\n            });\n            const end = tokenStream.stringposend(-1);\n            if (rawNode.type == \"error\" && restartOnFailure)\n                tokenStream.setpos(oldpos);\n            return {\n                id: newid(),\n                start,\n                end,\n                ...rawNode,\n            };\n        }\n        catch (err) {\n            if (restartOnFailure)\n                tokenStream.setpos(oldpos);\n            const errnode = err;\n            if (errnode.start === undefined)\n                delete errnode.start;\n            if (errnode.end === undefined)\n                delete errnode.end;\n            return {\n                unitName,\n                id: newid(),\n                start,\n                end: tokenStream.stringpos(),\n                ...errnode,\n            };\n        }\n    };\n    let ctx = {\n        tokens: tokenStream,\n        node: nodeAssembler,\n    };\n    const rootNode = parseBlock(ctx, true);\n    return rootNode;\n}\nexport function parseMatch(ctx) {\n    return ctx.node((a) => {\n        const branches = [];\n        a.expectToken(\"{\");\n        // get branches\n        let lhs;\n        while (!a.isNextToken(\"}\")) {\n            lhs = a.expectExpression();\n            if (!a.isNextToken(\":\"))\n                break;\n            a.expectToken(\":\");\n            const rhs = a.expectExpression();\n            branches.push([lhs, rhs]);\n            if (!a.isNextToken(\"}\")) {\n                a.expectToken(\",\");\n            }\n        }\n        // get optional fallback\n        let fallback = undefined;\n        if (a.isNextToken(\"}\") || a.isNextToken(\",\")) {\n            fallback = lhs;\n        }\n        // allow trailing comma\n        a.consumeTokenIfExists(\",\");\n        a.expectToken(\"}\");\n        return {\n            branches,\n            fallback,\n            type: \"match\",\n        };\n    });\n}\n// bad parsing in blocks is handled in a special manner\n// to prevent blocks from being turned into error nodes and disabling\n// autocomplete and other useful language features.\nexport function parseBlock(ctx, isRoot) {\n    return ctx.node((a) => {\n        const body = [];\n        if (!isRoot)\n            a.expectToken(\"{\");\n        // body statements/expressions\n        while ((!isRoot && !a.isNextToken(\"}\") && !a.isEnd()) ||\n            (isRoot && !a.isEnd())) {\n            body.push(a.expectExpressionOrStatement());\n            // makes sure that certain types of expressions/statements have line break\n            const last = body[body.length - 1];\n            if ((!isRoot && !a.isNextToken(\"}\")) || (isRoot && !a.isEnd())) {\n                if (last.type == \"note\" || last.type == \"linebreak\") {\n                    a.consumeTokenIfExists(\";\");\n                }\n                else if (last.type == \"assignment\" || asExpr(last).success) {\n                    const start = ctx.tokens.stringpos();\n                    if (!a.isNextToken(\";\")) {\n                        body.push(ctx.node((a) => {\n                            while (!a.isNextToken(\";\") && !a.isEnd()) {\n                                a.maybeNext();\n                            }\n                            return { reason: \"expected a ';' here\", type: \"error\" };\n                        }));\n                    }\n                    a.expectToken(\";\");\n                }\n                else {\n                    a.consumeTokenIfExists(\";\");\n                }\n            }\n        }\n        a.consumeTokenIfExists(\";\");\n        if (!isRoot)\n            a.expectToken(\"}\");\n        return { body, type: \"block\", isRoot };\n    });\n}\nexport function parseNumber(ctx) {\n    return ctx.node((a) => {\n        const token = a.expectTokenType(\"number\");\n        a.highlightLastToken(\"number\");\n        return { number: Number(token.str), type: \"number\" };\n    });\n}\nexport function parseIdentifier(ctx) {\n    return ctx.node((a) => {\n        const segments = [];\n        let first = true;\n        while (first ||\n            a.isNextToken(\".\") ||\n            a.isNextToken(\".x\") ||\n            a.isNextToken(\".y\")) {\n            if (!first) {\n                if (a.isNextToken(\".x\") || a.isNextToken(\".y\")) {\n                    const op = a.expectTokenType(\"op\");\n                    a.highlightLastToken(\"keyword\");\n                    segments.push(op.str[1]);\n                    continue;\n                }\n                else {\n                    a.expectToken(\".\");\n                }\n            }\n            first = false;\n            segments.push(a.expectTokenType(\"ident\").str);\n            if (a.isNextToken(\".\") || a.isNextToken(\".x\") || a.isNextToken(\".y\"))\n                a.highlightLastToken(\"variable\");\n        }\n        return { type: \"identifier\", segments };\n    });\n}\nexport function parseListOrRange(a, initElem) {\n    const elements = [initElem];\n    // one-element list case\n    if (a.isNextToken(\"]\")) {\n        a.maybeNext();\n        return {\n            elements: [initElem],\n            type: \"list\",\n        };\n        // range with no step\n    }\n    else if (a.isNextToken(\"..\")) {\n        a.maybeNext();\n        const rhs = a.expectExpression();\n        a.expectToken(\"]\");\n        return { type: \"range\", lhs: initElem, rhs };\n    }\n    a.expectToken(\",\");\n    const secondElement = a.expectExpression();\n    // range with step\n    if (a.isNextToken(\"..\")) {\n        a.maybeNext();\n        const rhs = a.expectExpression();\n        a.expectToken(\"]\");\n        return {\n            type: \"range\",\n            lhs: initElem,\n            rhs,\n            step: secondElement,\n        };\n    }\n    elements.push(secondElement);\n    // rest of list\n    while (true) {\n        if (a.isNextToken(\"]\"))\n            break;\n        a.expectToken(\",\");\n        if (a.isNextToken(\"]\"))\n            break;\n        elements.push(a.expectExpression());\n    }\n    a.expectToken(\"]\");\n    return {\n        elements,\n        type: \"list\",\n    };\n}\nexport function parseListcomp(a, body) {\n    const params = [];\n    while (true) {\n        if (a.isNextToken(\"]\"))\n            break;\n        const left = a.expectTokenType(\"ident\").str;\n        a.highlightLastToken(\"variable\");\n        a.expectToken(\"=\");\n        const right = a.expectExpression();\n        params.push([left, right]);\n        if (a.isNextToken(\"]\"))\n            break;\n        a.expectToken(\",\");\n    }\n    a.expectToken(\"]\");\n    return {\n        type: \"listcomp\",\n        params,\n        body,\n    };\n}\nexport function parseListOrListcomp(ctx) {\n    return ctx.node((a) => {\n        a.expectToken(\"[\");\n        if (a.isNextToken(\"]\")) {\n            a.maybeNext();\n            a.expectToken(\"as\", \"empty lists must have type annotations\");\n            a.highlightLastToken(\"keyword\");\n            const type = a.expectOneOfTheseTokens([\"point\", \"number\", \"polygon\", \"color\", \"boolean\"], `invalid type: valid list type annotation types are 'point', 'number', 'polygon', 'color', or 'boolean'`);\n            a.highlightLastToken(\"type\");\n            a.expectToken(\"[\");\n            a.expectToken(\"]\");\n            return { elements: [], type: \"list\", typeAnnotation: type.str };\n        }\n        const initExpr = a.expectExpression();\n        if (a.isNextToken(\",\") || a.isNextToken(\"]\") || a.isNextToken(\"..\")) {\n            return parseListOrRange(a, initExpr);\n        }\n        else {\n            a.expectToken(\"for\");\n            a.highlightLastToken(\"keyword\");\n            return parseListcomp(a, initExpr);\n        }\n    });\n}\nexport function parseNote(ctx) {\n    return ctx.node((a) => {\n        const note = a.expectTokenType(\"note\");\n        a.highlightLastToken(\"string\");\n        return {\n            type: \"note\",\n            content: note.str.slice(1, -1),\n        };\n    });\n}\nexport function parseParenthesizedOrPoint(ctx) {\n    return ctx.node((a) => {\n        a.expectToken(\"(\");\n        const x = a.expectExpression();\n        // if this is a parenthesized expression, end early\n        if (a.isNextToken(\")\")) {\n            a.maybeNext();\n            return x;\n        }\n        a.expectToken(\",\", \"expected ',' (if a point) or ')' (if a paraenthesized expression)\");\n        const y = a.expectExpression();\n        a.expectToken(\")\");\n        return { type: \"point\", x, y };\n    });\n}\nexport function parseFunctionCall(ctx) {\n    return ctx.node((a) => {\n        const name = parseIdentifier(ctx);\n        if (name.type != \"identifier\")\n            return a.error(\"expected an identifier\");\n        a.expectToken(\"(\");\n        const params = [];\n        while (!a.isEnd()) {\n            if (a.isNextToken(\")\"))\n                break;\n            params.push(a.expectExpression());\n            if (a.isNextToken(\")\"))\n                break;\n            a.expectToken(\",\");\n        }\n        a.expectToken(\")\");\n        return {\n            type: \"fncall\",\n            name: name,\n            params,\n        };\n    });\n}\nexport function parseMacroCall(ctx) {\n    return ctx.node((a) => {\n        const name = parseIdentifier(ctx);\n        if (name.type != \"identifier\")\n            return a.error(\"expected an identifier\");\n        a.expectToken(\"!\");\n        a.expectToken(\"(\");\n        const params = [];\n        while (true) {\n            if (a.isNextToken(\")\"))\n                break;\n            params.push(a.expectAny());\n            if (a.isNextToken(\")\"))\n                break;\n            a.expectToken(\",\");\n        }\n        a.expectToken(\")\");\n        return {\n            type: \"macrocall\",\n            name: name,\n            params,\n        };\n    });\n}\nexport function parseUnaryOp(ctx) {\n    return ctx.node((a) => {\n        a.expectToken(\"-\");\n        const operand = a.expectExpression(6);\n        return {\n            type: \"unop\",\n            op: \"-\",\n            operand,\n        };\n    });\n}\nexport function parseInitExpr(ctx, a, initToken) {\n    switch (initToken.type) {\n        case \"note\":\n            return parseNote(ctx);\n        case \"number\":\n            return parseNumber(ctx);\n        case \"ident\":\n            let pos = a.getpos();\n            let node = parseFunctionCall(ctx);\n            if (getErrors(node).length == 0)\n                return node;\n            a.setpos(pos);\n            let node2 = parseMacroCall(ctx);\n            if (getErrors(node2).length == 0)\n                return node2;\n            a.setpos(pos);\n            return parseIdentifier(ctx);\n        default:\n            switch (initToken.str) {\n                case \"-\":\n                    return parseUnaryOp(ctx);\n                case \"[\":\n                    return parseListOrListcomp(ctx);\n                case \"(\":\n                    return parseParenthesizedOrPoint(ctx);\n                case \"{\":\n                    let pos2 = a.getpos();\n                    let node2 = parseBlock(ctx);\n                    if (getErrors(node2).length == 0)\n                        return node2;\n                    a.setpos(pos2);\n                    return parseMatch(ctx);\n            }\n            throw a.tokenError(`unexpected token '${initToken.str}'`);\n    }\n}\nexport const bindingPowers = {\n    \"^\": 4,\n    \"*\": 3,\n    \"/\": 3,\n    \"+\": 2,\n    \"-\": 2,\n    \">=\": 5,\n    \"<=\": 5,\n    \"==\": 5,\n    \">\": 5,\n    \"<\": 5,\n    \"->\": 6,\n    \"[\": 7,\n};\nexport const rightAssociative = {\n    \"^\": true,\n};\nexport function isRightAssociative(token) {\n    return rightAssociative[token.str] ?? false;\n}\nexport function getBindingPowerStr(str) {\n    return bindingPowers[str] ?? 0;\n}\nexport function getBindingPower(token) {\n    return bindingPowers[token.str] ?? 0;\n}\nexport function parseBinaryOp(ctx, leftNode) {\n    return ctx.node((a) => {\n        //if (leftNode.type == \"error\") return leftNode;\n        const op = a.expectTokenType(\"op\");\n        const rhs = a.expectExpression(getBindingPower(op) - (isRightAssociative(op) ? 1 : 0));\n        return {\n            type: \"binop\",\n            lhs: leftNode,\n            start: leftNode.start,\n            rhs,\n            op: op.str,\n        };\n    });\n}\nexport function parseConsequentExpr(ctx, leftNode, token) {\n    // handle array subscript\n    if (token.str == \"[\") {\n        return ctx.node((a) => {\n            a.maybeNext();\n            const rhs = a.expectExpression();\n            a.expectToken(\"]\");\n            return {\n                type: \"binop\",\n                lhs: leftNode,\n                start: leftNode.start,\n                rhs,\n                op: \"[\",\n            };\n        });\n    }\n    switch (token.type) {\n        case \"op\":\n            return parseBinaryOp(ctx, leftNode);\n        default:\n            return;\n    }\n}\nexport function parseExpr(ctx, currentBindingPower) {\n    return ctx.node((a) => {\n        const initToken = a.peek();\n        let leftNode = parseInitExpr(ctx, a, initToken);\n        while (true) {\n            if (leftNode.type == \"error\")\n                return leftNode;\n            const nextToken = a.maybePeek();\n            if (!nextToken)\n                break;\n            if (getBindingPower(nextToken) <= currentBindingPower)\n                break;\n            const consequentExpr = parseConsequentExpr(ctx, leftNode, nextToken);\n            if (!consequentExpr)\n                break;\n            leftNode = consequentExpr;\n        }\n        return leftNode;\n    });\n}\nexport function parseAssignment(ctx) {\n    return ctx.node((a) => {\n        const lhs = a.expectTokenType(\"ident\").str;\n        a.highlightLastToken(\"variable\");\n        // custom error message if assigning to namespaced variables\n        if (a.isNextToken(\".\")) {\n            return a.error(\"Variables being assigned to cannot contain '.' characters!\");\n        }\n        a.expectToken(\"=\");\n        const rhs = a.expectExpression();\n        if (rhs.type == \"error\")\n            while (!a.isNextToken(\";\") && !a.isNextToken(\"}\") && !a.isEnd())\n                a.maybeNext();\n        return { lhs, rhs, type: \"assignment\" };\n    });\n}\nexport function parseImport(ctx) {\n    return ctx.node((a) => {\n        a.expectToken(\"import\");\n        a.highlightLastToken(\"keyword\");\n        const isScript = a.consumeTokenIfExists(\"script\");\n        if (isScript) {\n            a.highlightLastToken(\"keyword\");\n            const src = a.expectTokenType(\"note\").str.slice(1, -1);\n            a.highlightLastToken(\"string\");\n            return { type: \"import-script\", src };\n        }\n        const src = a.expectTokenType(\"note\").str.slice(1, -1);\n        a.highlightLastToken(\"string\");\n        let alias;\n        if (a.isNextToken(\"as\")) {\n            a.maybeNext();\n            a.highlightLastToken(\"keyword\");\n            alias = a.expectTokenType(\"ident\").str;\n            a.highlightLastToken(\"namespace\");\n        }\n        return { type: \"import\", src, alias };\n    });\n}\nexport function parseFunctionDef(ctx) {\n    return ctx.node((a) => {\n        a.expectToken(\"fn\");\n        a.highlightLastToken(\"keyword\");\n        const name = a.expectTokenType(\"ident\").str;\n        a.highlightLastToken(\"function\");\n        a.expectToken(\"(\");\n        const params = [];\n        while (!a.isNextToken(\")\")) {\n            params.push(a.expectTokenType(\"ident\").str);\n            a.highlightLastToken(\"variable\");\n            if (!a.isNextToken(\")\")) {\n                a.expectToken(\",\");\n            }\n            else {\n                a.consumeTokenIfExists(\",\");\n            }\n        }\n        a.expectToken(\")\");\n        let oldpos = a.getpos();\n        let body = parseBlock(ctx);\n        if (body.type == \"error\") {\n            a.setpos(oldpos);\n            body = parseMatch(ctx);\n        }\n        if (body.type == \"error\") {\n            a.error(\"expected a function body surrounded by '{}' brackets or a match expression\");\n        }\n        return { type: \"fndef\", params, body, name };\n    });\n}\nexport function parseNamespace(ctx) {\n    return ctx.node((a) => {\n        a.expectToken(\"ns\");\n        a.highlightLastToken(\"keyword\");\n        const name = a.expectTokenType(\"ident\").str;\n        a.highlightLastToken(\"namespace\");\n        let settings = undefined;\n        if (a.isNextToken(\"@\")) {\n            settings = a.expectJson();\n        }\n        const body = a.expectExpression();\n        if (body.type != \"block\") {\n            a.error(\"expected a block of expressions or statements\");\n        }\n        return {\n            type: \"namespace\",\n            body,\n            name,\n            settings,\n        };\n    });\n}\nexport function parseShow(ctx) {\n    return ctx.node((a) => {\n        a.expectToken(\"show\");\n        a.highlightLastToken(\"keyword\");\n        const body = a.expectExpressionOrStatement();\n        const settings = a.expectJson(true);\n        return { type: \"show\", settings, body };\n    });\n}\nexport function parseSettings(ctx) {\n    return ctx.node((a) => {\n        const token = a.expectOneOfTheseTokens([\"settings\", \"ticker\"]);\n        a.highlightLastToken(\"keyword\");\n        const content = a.expectJson();\n        return {\n            type: \"settings\",\n            settingsType: token.str,\n            content,\n        };\n    });\n}\nexport function parseStatement(ctx) {\n    return ctx.node((a) => {\n        const nextToken = a.peek(true);\n        // keep track of line breaks for formatting purposes\n        if (nextToken.type == \"whitespace\") {\n            a.maybeNext(true);\n            return {\n                type: \"linebreak\",\n            };\n        }\n        switch (nextToken.str) {\n            case \"import\":\n                return parseImport(ctx);\n            case \"fn\":\n                return parseFunctionDef(ctx);\n            case \"ns\":\n                return parseNamespace(ctx);\n            case \"show\":\n                return parseShow(ctx);\n            case \"settings\":\n            case \"ticker\":\n                return parseSettings(ctx);\n            default:\n                switch (nextToken.type) {\n                    case \"ident\":\n                        return parseAssignment(ctx);\n                    case \"note\":\n                        return parseNote(ctx);\n                    default:\n                        const err = a.error(\"expected a statement\");\n                        return err;\n                }\n        }\n    });\n}\nexport function parseJson(ctx, topLevel) {\n    return ctx.node((a) => {\n        if (topLevel) {\n            a.expectToken(\"@\");\n            a.highlightLastToken(\"keyword\");\n        }\n        else {\n            if (a.isNextToken(\"@\")) {\n                a.maybeNext();\n                a.highlightLastToken(\"keyword\");\n            }\n        }\n        const nextToken = a.peek();\n        switch (nextToken.type) {\n            case \"number\":\n                return parseNumber(ctx);\n            case \"note\":\n                return parseNote(ctx);\n            case \"ident\":\n                switch (nextToken.str) {\n                    case \"null\":\n                        a.maybeNext();\n                        a.highlightLastToken(\"macro\");\n                        return { type: \"json-null\" };\n                    case \"true\":\n                        a.maybeNext();\n                        a.highlightLastToken(\"macro\");\n                        return { type: \"json-boolean\", data: true };\n                    case \"false\":\n                        a.maybeNext();\n                        a.highlightLastToken(\"macro\");\n                        return { type: \"json-boolean\", data: false };\n                    case \"ds\":\n                        a.maybeNext();\n                        a.highlightLastToken(\"keyword\");\n                        a.expectToken(\"(\");\n                        const expr = a.expectExpression();\n                        a.expectToken(\")\");\n                        return { type: \"json-inner-expr\", expr };\n                }\n            default:\n                if (nextToken.str == \"{\") {\n                    a.expectToken(\"{\");\n                    let data = [];\n                    let first = true;\n                    while (true) {\n                        if (a.isNextToken(\"}\"))\n                            break;\n                        if (!first)\n                            a.expectToken(\",\");\n                        if (a.isNextToken(\"}\"))\n                            break;\n                        first = false;\n                        const lhs = a.expectTokenType(\"ident\").str;\n                        a.highlightLastToken(\"variable\");\n                        a.expectToken(\":\");\n                        const rhs = a.expectJson();\n                        data.push([lhs, rhs]);\n                    }\n                    a.expectToken(\"}\");\n                    return { type: \"json-object\", data };\n                }\n                if (nextToken.str == \"[\") {\n                    a.expectToken(\"[\");\n                    let elements = [];\n                    while (true) {\n                        if (a.isNextToken(\"]\"))\n                            break;\n                        elements.push(a.expectJson());\n                        if (a.isNextToken(\"]\"))\n                            break;\n                        a.expectToken(\",\");\n                    }\n                    a.expectToken(\"]\");\n                    return { type: \"json-array\", elements };\n                }\n                return a.error(\"expected a desmoscript json expression\");\n        }\n    });\n}\n","import { asExpr } from \"./ast\";\nimport { getBindingPowerStr } from \"../parse/parse\";\nexport function indent(n) {\n    return \"\".padStart(n, \" \");\n}\nexport function maxLineLength(str) {\n    return str.split(\"\\n\").reduce((prev, curr) => Math.max(prev, curr.length), 0);\n}\nexport function formatAST(n, c) {\n    let ctx;\n    if (!c) {\n        ctx = { indent: 0, tabSize: 2, maxlen: 80, bindingPower: 0 };\n    }\n    else {\n        ctx = c;\n    }\n    const ctxwith = (patch) => {\n        return {\n            ...ctx,\n            splitByLine: undefined,\n            dontIndentFirst: undefined,\n            ...patch,\n        };\n    };\n    switch (n.type) {\n        // TODO: wrap after line if too long\n        case \"assignment\":\n            return `${n.lhs} = ${formatAST(n.rhs, ctxwith({\n                indent: ctx.indent,\n            }))}`;\n        // binary operation rules:\n        // if tree is less than maxlen, keep it all in a single line\n        // if tree is greater than maxlen, split it up with ops at beginning\n        case \"binop\":\n            if (ctx.splitByLine === undefined) {\n                let str = formatAST(n, ctxwith({ splitByLine: false }));\n                if (str.length > ctx.maxlen) {\n                    str = formatAST(n, ctxwith({\n                        splitByLine: true,\n                        bindingPower: getBindingPowerStr(n.op),\n                    }));\n                }\n                return str;\n            }\n            const bindingPower = getBindingPowerStr(n.op);\n            // split by line\n            if (ctx.splitByLine) {\n                // if there's an increase in binding power,\n                // try to merge lines\n                if (bindingPower != ctx.bindingPower) {\n                    return formatAST(n, ctxwith({\n                        splitByLine: false,\n                        bindingPower: ctx.bindingPower,\n                        indent: ctx.indent + ctx.tabSize,\n                    }));\n                }\n                let l = formatAST(n.lhs, ctxwith({ bindingPower, splitByLine: true }));\n                let r = formatAST(n.rhs, ctxwith({ bindingPower, splitByLine: true }));\n                // split by line\n                let str = n.op == \"[\"\n                    ? `${l}[\\n${r}\\n]`\n                    : `${l}\\n${indent(ctx.indent)}${n.op} ${r}`;\n                // parenthesize if current binding power would be less than previous\n                if (bindingPower < ctx.bindingPower)\n                    return `(${str})`;\n                return str;\n            }\n            else {\n                let l = formatAST(n.lhs, ctxwith({ bindingPower }));\n                let r = formatAST(n.rhs, ctxwith({ bindingPower }));\n                let str = n.op == \"[\" ? `${l}[${r}]` : `${l} ${n.op} ${r}`;\n                if (bindingPower < ctx.bindingPower)\n                    return `(${str})`;\n                return str;\n            }\n        case \"block\":\n            let rootOffset = n.isRoot ? 0 : ctx.tabSize;\n            return `${ctx.dontIndentFirst ? \"\" : /*indent(ctx.indent)*/ \"\"}${n.isRoot ? \"\" : \"{\"}${n.isRoot ? \"\" : \"\\n\"}${n.body\n                .map((e, i) => `${indent(ctx.indent + rootOffset)}${formatAST(e, ctxwith({ indent: ctx.indent + ctx.tabSize + rootOffset }))}` +\n                ((e.type != \"note\" &&\n                    asExpr(e).success &&\n                    i != n.body.length - 1) ||\n                    e.type == \"assignment\"\n                    ? \";\"\n                    : \"\") +\n                \"\\n\")\n                .join(\"\")}${indent(ctx.indent)}${n.isRoot ? \"\" : \"}\"}`;\n        case \"error\":\n            // TODO: figure out how to deal with this properly\n            return `##ERROR: ${n.reason}##`;\n        case \"fncall\":\n            const fnname = formatAST(n.name);\n            const fnparams = n.params.map((p) => formatAST(p, ctxwith({ indent: ctx.indent + ctx.tabSize })));\n            let str = `${fnname}(${fnparams.join(\", \")})`;\n            // split function call by lines if too long\n            if (maxLineLength(str) > ctx.maxlen) {\n                return `${fnname}(\\n${fnparams.join(`,\\n${indent(ctx.indent + ctx.tabSize)}`)}\\n${indent(ctx.indent)})`;\n            }\n            return str;\n        case \"fndef\": {\n            const fndefparams = n.params.join(\", \");\n            const nextIndent = ctxwith({\n                indent: ctx.indent - ctx.tabSize,\n                dontIndentFirst: true,\n            });\n            const str = `fn ${n.name}(${fndefparams}) ${formatAST(n.body, nextIndent)}`;\n            if (fndefparams.length > ctx.maxlen) {\n                return `fn ${n.name}(\\n${n.params.join(`,\\n${indent(ctx.indent + ctx.tabSize)}`)}\\n) ${formatAST(n.body, nextIndent)}`;\n            }\n            return str;\n        }\n        case \"identifier\":\n            return n.segments.join(\".\");\n        case \"import\":\n            return `import \"${n.src}\"` + (n.alias ? ` as ${n.alias}` : \"\");\n        case \"import-script\":\n            return `import script \"${n.src}\"`;\n        case \"json-array\": {\n            const nextIndent = ctxwith({ indent: ctx.indent + ctx.tabSize });\n            const data = n.elements.map((d) => formatAST(d, nextIndent));\n            const str = `[${data.join(\", \")}]`;\n            if (str.length > ctx.maxlen) {\n                return `[\\n${data.join(`,\\n${indent(ctx.indent)}`)}\\n${indent(ctx.indent - ctx.tabSize)}]`;\n            }\n            return str;\n        }\n        case \"json-boolean\":\n            return n.data ? \"true\" : \"false\";\n        case \"json-inner-expr\":\n            return `ds(${formatAST(n.expr, ctxwith({ indent: ctx.indent + ctx.tabSize }))})`;\n        case \"json-null\":\n            return `null`;\n        case \"json-object\": {\n            const nextIndent = ctxwith({ indent: ctx.indent + ctx.tabSize });\n            const data = n.data.map(([k, v]) => `${k}: ${formatAST(v, nextIndent)}`);\n            const str = `@{ ${data.join(\", \")} }`;\n            if (str.length > ctx.maxlen) {\n                return `@{${data\n                    .map((e) => `\\n${indent(ctx.indent)}${e}`)\n                    .join(\",\")}\\n${indent(ctx.indent - ctx.tabSize)}}`;\n            }\n            return str;\n        }\n        case \"linebreak\":\n            return ``;\n        case \"list\": {\n            const annotation = n.typeAnnotation ? ` as ${n.typeAnnotation}[]` : \"\";\n            const elements = n.elements.map((e) => formatAST(e, ctxwith({ indent: ctx.indent + ctx.tabSize })));\n            const str = `[${elements.join(\", \")}]` + annotation;\n            if (str.length > ctx.maxlen) {\n                return (`[${elements\n                    .map((e) => `\\n${indent(ctx.indent)}${e}`)\n                    .join(\",\")}\\n${indent(ctx.indent - ctx.tabSize)}]` + annotation);\n            }\n            return str;\n        }\n        case \"listcomp\": {\n            const body = formatAST(n.body, ctxwith({ indent: ctx.indent + ctx.tabSize }));\n            const params = n.params.map(([k, v]) => {\n                return `${k}=${formatAST(v, ctxwith({ indent: ctx.indent + ctx.tabSize }))}`;\n            });\n            const str = `[${body} for ${params.join(\", \")}]`;\n            // TODO: expand if too large\n            if (maxLineLength(str) > ctx.maxlen) {\n                return `[${body} for${params\n                    .map((e) => `\\n${indent(ctx.indent)}${e}`)\n                    .join(\",\")}\\n${indent(ctx.indent - ctx.tabSize)}]`;\n            }\n            return str;\n        }\n        case \"macrocall\": {\n            const fnname = formatAST(n.name);\n            const fnparams = n.params.map((p) => formatAST(p, ctxwith({ indent: ctx.indent + ctx.tabSize })));\n            let str = `${fnname}!(${fnparams.join(\", \")})`;\n            // split function call by lines if too long\n            if (maxLineLength(str) > ctx.maxlen) {\n                return `${fnname}!(\\n${fnparams.join(`,\\n${indent(ctx.indent + ctx.tabSize)}`)}\\n${indent(ctx.indent)})`;\n            }\n            return str;\n        }\n        case \"match\": {\n            const nextIndent = ctxwith({ indent: ctx.indent + ctx.tabSize });\n            const branches = n.branches.map(([k, v]) => {\n                return `${formatAST(k, nextIndent)}: ${formatAST(v, nextIndent)}`;\n            });\n            const fallback = n.fallback ? formatAST(n.fallback, nextIndent) : \"\";\n            const str = `{ ${[...branches, fallback].filter((e) => e).join(\", \")} }`;\n            if (str.length > ctx.maxlen) {\n                return `{${[...branches, fallback]\n                    .filter((e) => e)\n                    .map((e) => `\\n${indent(ctx.indent)}${e}`)\n                    .join(\",\")}\\n${indent(ctx.indent - ctx.tabSize)}}`;\n            }\n            return str;\n        }\n        case \"namespace\":\n            return `ns ${n.name} ${n.settings\n                ? formatAST(n.settings, ctxwith({\n                    dontIndentFirst: true,\n                })) + \" \"\n                : \"\"}${formatAST(n.body, ctxwith({ indent: ctx.indent - ctx.tabSize, dontIndentFirst: true }))}`;\n        case \"note\":\n            return `\"${n.content}\"`;\n        case \"number\":\n            return n.number.toString();\n        case \"point\": {\n            const nextIndent = ctxwith({ indent: ctx.indent + ctx.tabSize });\n            const x = formatAST(n.x, nextIndent);\n            const y = formatAST(n.y, nextIndent);\n            const str = `(${x}, ${y})`;\n            if (str.length > ctx.maxlen) {\n                return `(\\n${indent(ctx.indent + ctx.tabSize)}${x},\\n${indent(ctx.indent + ctx.tabSize)}${y}\\n)`;\n            }\n            return str;\n        }\n        case \"range\":\n            const nextIndent = ctxwith({ indent: ctx.indent + ctx.tabSize });\n            const lhs = formatAST(n.lhs, nextIndent);\n            const rhs = formatAST(n.rhs, nextIndent);\n            if (n.step)\n                return `[${lhs},${formatAST(n.step, nextIndent)}..${rhs}]`;\n            return `[${lhs}..${rhs}]`;\n        case \"show\":\n            return `show ${formatAST(n.body, ctx)} ${formatAST(n.settings, ctx)}`;\n        case \"unop\": {\n            const nextIndent = ctxwith({\n                indent: ctx.indent + ctx.tabSize,\n                bindingPower: getBindingPowerStr(n.op),\n            });\n            if (n.op.startsWith(\".\")) {\n                return `${formatAST(n.operand, nextIndent)}${n.op}`;\n            }\n            else {\n                return `${n.op}${formatAST(n.operand, nextIndent)}`;\n            }\n        }\n        case \"settings\": {\n            const nextIndent = ctxwith({ indent: ctx.indent + ctx.tabSize });\n            return `${n.settingsType} ${formatAST(n.content, nextIndent)}`;\n        }\n    }\n}\n","import { newid, asExpr, } from \"../ast/ast\";\nimport { compilerError, internalError, } from \"../compiler-errors\";\nexport function mapASTToAddScopes(node, mapper) {\n    function map(n) {\n        // handle arrays within astnodes\n        //@ts-ignore\n        if (Array.isArray(n))\n            return n.map((e) => map(e));\n        //@ts-ignore\n        if (n && typeof n == \"object\" && typeof n.id == \"number\") {\n            // handle current node\n            //@ts-ignore\n            if (n !== node) {\n                //@ts-ignore\n                return mapper(n);\n            }\n            // handle direct child nodes\n            const node2 = n;\n            //@ts-ignore\n            return Object.fromEntries(Object.entries(node2).map(([k, v]) => [k, map(v)]));\n        }\n        // handle all other properties\n        //@ts-ignore\n        return n;\n    }\n    //@ts-ignore\n    return map(node);\n}\nexport function newScope(parent, name, ctx, start, end, isWithinFunction) {\n    const scope = {\n        elements: new Map(),\n        imports: [],\n        parent,\n        name,\n        importScripts: [],\n    };\n    if (parent) {\n        addToScope(parent, name, {\n            type: \"scope\",\n            scope,\n            id: newid(),\n            unitName: ctx.unit,\n            start,\n            end,\n            isWithinFunction,\n        }, ctx.errors);\n    }\n    return scope;\n}\nexport function addToScope(scope, name, content, errors) {\n    const existing = scope.elements.get(name);\n    // throw namespace collision error\n    if (existing && existing.type != \"builtin-variable\") {\n        let start = 0;\n        let end = 0;\n        if (existing.type != \"builtin-function\" &&\n            //existing.type != \"builtin-variable\" &&\n            existing.type != \"macro\") {\n            start = existing.start;\n            end = existing.end;\n        }\n        let namespaceCollision = {\n            reason: `namespace collision`,\n            type: \"namespace-collision\",\n            start,\n            end,\n            startB: content.type != \"macro\" ? content?.start : undefined,\n            endB: content.type != \"macro\" ? content?.end : undefined,\n            unitB: content.unitName,\n            unit: existing.unitName,\n        };\n        errors.push(namespaceCollision);\n    }\n    scope.elements.set(name, content);\n}\nexport function addScopesToAST(node, state, ctx) {\n    const child = (n, innerScope, isValueBlock) => {\n        return addScopesToAST(n, {\n            parentNode: node,\n            scope: innerScope ?? state.scope,\n            isValueBlock: isValueBlock ?? true,\n        }, ctx);\n    };\n    const getDisplay = () => {\n        return state.parentNode?.type == \"show\"\n            ? state.parentNode.settings.id\n            : undefined;\n    };\n    switch (node.type) {\n        case \"fndef\": {\n            let innerScope = newScope(state.scope, newid().toString(), ctx, node.start, node.end, true);\n            innerScope.name = node.name;\n            addToScope(state.scope, node.name, {\n                type: \"function\",\n                node: node.id,\n                start: node.start,\n                end: node.end,\n                unitName: ctx.unit,\n                display: getDisplay(),\n                id: newid(),\n            }, ctx.errors);\n            for (const p of node.params) {\n                addToScope(innerScope, p, {\n                    type: \"builtin-variable\",\n                    unitName: ctx.unit,\n                    id: newid(),\n                }, ctx.errors);\n            }\n            return {\n                ...node,\n                innerScope,\n                enclosingScope: state.scope,\n                body: child(node.body, innerScope),\n            };\n        }\n        case \"namespace\": {\n            const innerScope = newScope(state.scope, node.name, ctx, node.start, node.end);\n            return {\n                ...node,\n                innerScope,\n                enclosingScope: state.scope,\n                body: child(node.body, innerScope, false),\n                settings: node.settings ? child(node.settings, state.scope) : undefined,\n            };\n        }\n        case \"listcomp\": {\n            let innerScope = newScope(state.scope, \"listcomp\" + newid().toString(), ctx, node.start, node.end);\n            for (const [k, v] of node.params) {\n                addToScope(innerScope, k, {\n                    type: \"builtin-variable\",\n                    unitName: ctx.unit,\n                    id: newid(),\n                }, ctx.errors);\n            }\n            return {\n                ...node,\n                innerScope,\n                enclosingScope: state.scope,\n                body: child(node.body, innerScope),\n                params: node.params.map((p) => [p[0], child(p[1], state.scope)]),\n            };\n        }\n        case \"block\": {\n            // having a block create a namespace is redundant\n            // if it's directly within a function definition or a namespace\n            let innerScope = state.parentNode?.type == \"fndef\" ||\n                state.parentNode?.type == \"namespace\" ||\n                node.isRoot\n                ? state.scope\n                : newScope(state.scope, \"block\" + newid().toString(), ctx, node.start, node.end);\n            return {\n                ...node,\n                innerScope,\n                enclosingScope: state.scope,\n                body: node.body.map((e) => child(e, innerScope)),\n            };\n        }\n        case \"assignment\":\n            addToScope(state.scope, node.lhs, {\n                type: \"variable\",\n                node: node.id,\n                start: node.start,\n                end: node.end,\n                unitName: ctx.unit,\n                display: getDisplay(),\n                id: newid(),\n            }, ctx.errors);\n            break;\n        case \"note\":\n            addToScope(state.scope, newid().toString(), {\n                type: \"note\",\n                text: node.content,\n                start: node.start,\n                end: node.end,\n                unitName: ctx.unit,\n                id: newid(),\n            }, ctx.errors);\n            break;\n        case \"import\":\n            const resolvedImport = ctx.resolveImport(node.src, ctx.unit);\n            if (resolvedImport === undefined) {\n                ctx.errors.push(compilerError(`failed to import '${node.src}'`, node.start, node.end, ctx.unit));\n                break;\n            }\n            if (node.type == \"import\" && node.alias) {\n                addToScope(state.scope, node.alias, {\n                    type: \"import\",\n                    compilationUnitPath: resolvedImport,\n                    start: node.start,\n                    end: node.end,\n                    unitName: ctx.unit,\n                    id: newid(),\n                }, ctx.errors);\n            }\n            else {\n                state.scope.imports.push({\n                    compilationUnitPath: resolvedImport,\n                    start: node.start,\n                    end: node.end,\n                });\n            }\n            break;\n        case \"import-script\":\n            const resolvedImport2 = ctx.getAbsolutePath(ctx.unit, node.src);\n            if (!resolvedImport2) {\n                ctx.errors.push({\n                    type: \"general\",\n                    start: node.start,\n                    end: node.end,\n                    reason: `Import script '${resolvedImport2}' does not exist.`,\n                    unit: ctx.unit,\n                });\n                break;\n            }\n            const iscript = ctx.importScripts.get(resolvedImport2);\n            if (!iscript) {\n                ctx.errors.push({\n                    type: \"general\",\n                    start: node.start,\n                    end: node.end,\n                    reason: `Import script '${resolvedImport2}' does not exist.`,\n                    unit: ctx.unit,\n                });\n            }\n            iscript?.run({ scope: state.scope });\n            break;\n        case \"settings\":\n            addToScope(state.scope, newid().toString(), {\n                type: \"settings\",\n                settings: node.content.id,\n                start: node.start,\n                settingsType: node.settingsType,\n                end: node.end,\n                unitName: ctx.unit,\n                id: newid(),\n            }, ctx.errors);\n            break;\n        case \"macrocall\":\n            if (node.result && !(node.result instanceof Promise)) {\n                return {\n                    ...node,\n                    enclosingScope: state.scope,\n                    // don't do scope resolution on macro params\n                    params: node.params,\n                    name: child(node.name),\n                    // When generating scopes, macro calls are ignored\n                    // and don't count as parent nodes.\n                    result: addScopesToAST(node.result, {\n                        parentNode: state.parentNode,\n                        scope: state.scope,\n                    }, ctx),\n                };\n            }\n    }\n    if (\n    // add expression to scope if it's a non-note expression...\n    asExpr(node).success &&\n        node.type != \"note\" &&\n        // make sure the expression isn't a macro call\n        // if it is, make sure its result is actually an expression\n        (node.type != \"macrocall\" ||\n            (node.result &&\n                !(node.result instanceof Promise) &&\n                asExpr(node.result).success))) {\n        if (\n        // only add expressions to scope if they're within\n        // non-value blocks\n        (state.parentNode?.type == \"block\" &&\n            // or if they're not at the last position in a value block\n            (node != state.parentNode.body[state.parentNode.body.length - 1] ||\n                !state.isValueBlock ||\n                state.parentNode?.isRoot)) ||\n            // or if they're inside a \"show\" statement\n            state.parentNode?.type == \"show\") {\n            addToScope(state.scope, newid().toString(), {\n                type: \"expression\",\n                start: node.start,\n                end: node.end,\n                unitName: ctx.unit,\n                id: newid(),\n                expr: node.id,\n                display: getDisplay(),\n            }, ctx.errors);\n        }\n    }\n    return mapASTToAddScopes({\n        ...node,\n        enclosingScope: state.scope,\n    }, (childNode) => child(childNode));\n}\n// ensure that scopes don't contain namespace collisions from imports\n// that don't have aliasing\nexport function validateUnaliasedImports(scope, scopingContext, compilationContext) {\n    const combinedScopeContents = newScope(undefined, \"\", scopingContext, 0, 0);\n    const sourceScopes = [{ scope, unitName: scopingContext.unit }];\n    const visitedUnits = new Set(scopingContext.unit);\n    // get all the scopes to combine as a test\n    function gatherUnaliasedImportedScopes(searchScope, scopes, visitedUnits) {\n        for (const importInfo of searchScope.imports) {\n            if (visitedUnits.has(importInfo.compilationUnitPath))\n                continue;\n            const unit = compilationContext.compilationUnits.get(importInfo.compilationUnitPath);\n            if (!unit)\n                throw internalError(`expected a valid absolute import path; got '${importInfo.compilationUnitPath}'`);\n            visitedUnits.add(importInfo.compilationUnitPath);\n            scopes.push({\n                scope: unit.scopeTree,\n                unitName: importInfo.compilationUnitPath,\n            });\n            gatherUnaliasedImportedScopes(unit.scopeTree, scopes, visitedUnits);\n        }\n    }\n    // start gathering process\n    gatherUnaliasedImportedScopes(scope, sourceScopes, visitedUnits);\n    // attempt to merge all scopes together, revealing any namespace collisions\n    for (const { scope, unitName } of sourceScopes) {\n        for (const [k, v] of scope.elements.entries()) {\n            addToScope(combinedScopeContents, k, v, scopingContext.errors);\n        }\n    }\n}\n// gets the path of scope names that lead to a given scope\n// note that this won't work for indexing scope trees\nexport function getScopeNameList(scope, path) {\n    if (!scope)\n        return path ?? [];\n    return [...getScopeNameList(scope.parent), ...(path ?? [scope.name])];\n}\n// basically lookup a variable (or function etc) given a starting position\n// in the scope tree\n// takes into account imports and whatnot\nexport function findIdentifierScopeItem(compilationUnit, initSearchScope, identifierSegments, compilationContext, previouslySearchedUnits) {\n    // rule out compilation units we've already searched (eliminates circular searching)\n    if (previouslySearchedUnits?.has(compilationUnit.name))\n        return { result: \"not-found\" };\n    // get a list of scopes to search through to find the identifier\n    const scopePath = [];\n    let currentScope = initSearchScope;\n    while (currentScope) {\n        scopePath.push(currentScope);\n        currentScope = currentScope.parent;\n    }\n    // search through each of the scopes\n    for (const searchScope of scopePath) {\n        // traverse downwards using identifier segments\n        let identifierScope = searchScope;\n        for (let i = 0; i < identifierSegments.length; i++) {\n            const segment = identifierSegments[i];\n            let possibleNextIdentifierScope = identifierScope.elements.get(segment);\n            // found a scope content in this file\n            if (possibleNextIdentifierScope) {\n                // found scope content!\n                if (i == identifierSegments.length - 1) {\n                    return {\n                        result: \"found\",\n                        identifier: possibleNextIdentifierScope,\n                    };\n                }\n                // traverse scope in same file\n                if (possibleNextIdentifierScope.type == \"scope\") {\n                    identifierScope = possibleNextIdentifierScope.scope;\n                    // traverse scope in different file\n                }\n                else if (possibleNextIdentifierScope.type == \"import\") {\n                    const unit = compilationContext.compilationUnits.get(possibleNextIdentifierScope.compilationUnitPath);\n                    if (!unit)\n                        throw internalError(`expected a valid absolute import path; got '${possibleNextIdentifierScope.compilationUnitPath}'`);\n                    identifierScope = unit.scopeTree;\n                }\n                else {\n                    // handle case where the scope chain is just a misidentified point member access\n                    if (i == identifierSegments.length - 2 &&\n                        possibleNextIdentifierScope.type == \"variable\" &&\n                        (identifierSegments[identifierSegments.length - 1] == \"x\" ||\n                            identifierSegments[identifierSegments.length - 1] == \"y\")) {\n                        return {\n                            result: \"point-member-access\",\n                            identifier: possibleNextIdentifierScope,\n                            memberAccess: identifierSegments[identifierSegments.length - 1],\n                        };\n                    }\n                    break;\n                }\n                // attempt to find a scope content in other file\n            }\n            else {\n                for (const otherFile of identifierScope.imports) {\n                    // try to load other compilation unit\n                    const unit = compilationContext.compilationUnits.get(otherFile.compilationUnitPath);\n                    // make sure we don't search this unit twice\n                    previouslySearchedUnits?.add(otherFile.compilationUnitPath);\n                    if (!unit)\n                        throw internalError(`expected a valid absolute import path; got '${otherFile.compilationUnitPath}'`);\n                    // search for scope content in other compilation unit\n                    const searchResult = findIdentifierScopeItem(unit, unit.scopeTree, // search from the root scope\n                    identifierSegments.slice(i), compilationContext, previouslySearchedUnits ?? new Set(compilationUnit.name));\n                    if (searchResult.result != \"not-found\")\n                        return searchResult;\n                }\n            }\n        }\n    }\n    return { result: \"not-found\" };\n}\n","import { internalError } from \"../../compiler-errors\";\nimport { debugPrint } from \"../../debug/debug\";\n// prereq: a circular dependency must already exist\nexport function formatCircularDependencyError(expr, units, dependencyChain, offendingScopeItem, knownCircularDependencies) {\n    const entries = Array.from(dependencyChain.entries()).reverse();\n    const path = [];\n    for (const [k, v] of Array.from(dependencyChain.entries()).reverse()) {\n        path.push({\n            start: v.node.start ?? 0,\n            end: v.node.end ?? 0,\n            unit: v.nodeUnit,\n        });\n        knownCircularDependencies.add(v.content.id);\n        if (offendingScopeItem.id == v.content.id)\n            break;\n    }\n    path.reverse();\n    return errorType([\n        {\n            type: \"circular-dependency\",\n            start: offendingScopeItem.start ?? 0,\n            end: offendingScopeItem.end ?? 0,\n            unit: offendingScopeItem.unitName,\n            path,\n            reason: \"circular dependency: \",\n        },\n    ]);\n}\nexport function notFoundError(expr, unit, reason) {\n    return errorType([\n        { type: \"not-found\", start: expr.start, end: expr.end, unit, reason },\n    ]);\n}\nexport function wrongTypeError(expr, unit, reason) {\n    return errorType([\n        { type: \"wrong-type\", start: expr.start, end: expr.end, unit, reason },\n    ]);\n}\nexport function badMacroError(expr, errs, unit, reason) {\n    return errorType([\n        {\n            type: \"bad-macro\",\n            start: expr.start,\n            end: expr.end,\n            unit,\n            reason,\n            why: errs.map((err) => ({ ...err, type: \"general\", unit: err.unitName })),\n        },\n    ]);\n}\nexport function errorType(why) {\n    return { type: \"error\", why };\n}\nexport function assertNoError(type) {\n    if (type.type == \"error\")\n        throw internalError(\"expected a non-error type here\");\n    return type;\n}\nexport function formatScopeItemTypeName(typename) {\n    return typename.replace(\"-\", \" \");\n}\nexport function wrap(input, maxWidth) {\n    return input\n        .split(\"\\n\")\n        .map((line) => {\n        let indent = line.match(/^ */)?.[0].length ?? 0;\n        let lines = [];\n        let l = \"\";\n        let splitInput = line.split(\" \");\n        let i = 0;\n        for (const str of splitInput) {\n            l += str;\n            if (l.length > maxWidth || i == splitInput.length - 1) {\n                lines.push(l);\n                l = \"\";\n            }\n            else {\n                l += \" \";\n            }\n            i++;\n        }\n        return lines.join(\"\\n\".padEnd(indent + 1, \" \"));\n    })\n        .join(\"\\n\");\n}\nexport function indent(str, n) {\n    const indentation = \"\".padEnd(n, \" \");\n    return indentation + str.replace(/\\n/g, \"\\n\" + indentation);\n}\nexport function lastNewlinePos(str, pos, remaining) {\n    while (pos >= 0) {\n        if (str[pos] == \"\\n\")\n            remaining--;\n        if (remaining == 0)\n            return pos;\n        pos--;\n    }\n    return 0;\n}\nexport function nextNewlinePos(str, pos, remaining) {\n    while (pos < str.length) {\n        if (str[pos] == \"\\n\")\n            remaining--;\n        if (remaining == 0)\n            return pos;\n        pos++;\n    }\n    return str.length;\n}\nexport function formatCodeFragment(ctx, err, context) {\n    if (!context)\n        context = 2;\n    const unit = ctx.sourceCode.get(err.unit);\n    const [line, col] = unit.linesAndCols[err.start];\n    const lastNewline = lastNewlinePos(unit.src, err.start, context - 1);\n    const nextNewline = nextNewlinePos(unit.src, err.end, context);\n    let gutterLineNo = unit.linesAndCols[lastNewline][0];\n    let gutterPad = Math.floor(Math.log10(gutterLineNo + 2)) + 1;\n    const code = `\\n${unit.src.slice(lastNewline, err.start)}${ctx.format(unit.src.slice(err.start, err.end), {\n        type: \"error\",\n    })}${unit.src.slice(err.end, nextNewline)}`.replace(/\\n/g, (src) => \"\\n\" +\n        ctx.format((gutterLineNo++).toString().padEnd(gutterPad, \" \") + \"| \", {\n            type: \"gutter\",\n        }));\n    return code;\n}\nexport function formatError(ctx, err) {\n    const unit = ctx.sourceCode.get(err.unit);\n    debugPrint(err, err.start);\n    const [line, col] = unit.linesAndCols[err.start ?? 0] || [0, 0];\n    const baseErr = wrap(`Error in ${ctx.io.relativePath(ctx.entry, err.unit)}:${line}:${col} ${ctx.format(`(${err.unit}:${line}:${col})`, {\n        type: \"deemphasize\",\n    })}`, ctx.maxWidth) +\n        (ctx.hideSourceCode\n            ? \"\"\n            : formatCodeFragment(ctx, err, ctx.sourceCodeErrorContext ?? 2)) +\n        \"\\n\" +\n        ctx.format(err.reason, { type: \"message\" });\n    if (err.type == \"bad-fncall\" || err.type == \"bad-macro\") {\n        return (baseErr +\n            \"\\n\\n\" +\n            err.why\n                .map((e) => indent(formatError({ ...ctx, hideSourceCode: false }, e), 2))\n                .join(\"\\n  \"));\n    }\n    if (err.type == \"circular-dependency\") {\n        return (baseErr +\n            [...err.path, err.path[0]]\n                .map(({ start, end, unit }) => {\n                const unitData = ctx.sourceCode.get(unit);\n                const [line, col] = unitData.linesAndCols[start] || [0, 0];\n                const str = unitData.src.slice(start, end) || \"\";\n                return str;\n            })\n                .join(\" -> \") +\n            \"\\n\\n\" +\n            indent(err.path\n                .map(({ start, end, unit }) => {\n                const unitData = ctx.sourceCode.get(unit);\n                const [line, col] = unitData.linesAndCols[start] || [0, 0];\n                return `${ctx.format(`At ${unit}:${line}:${col}`, {\n                    type: \"deemphasize\",\n                })}${indent(formatCodeFragment(ctx, { start, end, unit }, ctx.sourceCodeErrorContext ?? 2), 2)}`;\n            })\n                .join(\"\\n\"), 2));\n    }\n    return baseErr;\n}\n","// handle typechecking for elementwise operations\nimport { wrongTypeError } from \"./type-errors\";\nimport { typecheckExpr, typeAsStr, } from \"./typecheck\";\n// where if any argument is a list, the entire output is a list\nfunction typecheckElementwise(a, b, handler) {\n    const primitiveTest = handler(a, b);\n    if (primitiveTest)\n        return primitiveTest;\n    let result = undefined;\n    if (a.type == \"list\") {\n        if (b.type == \"list\") {\n            result = handler(a.element, b.element);\n        }\n        else {\n            result = handler(a.element, b);\n        }\n    }\n    else if (b.type == \"list\") {\n        result = handler(a, b.element);\n    }\n    if (result)\n        return {\n            type: \"list\",\n            element: result,\n        };\n    return undefined;\n}\nexport function typecheckBinopAddSub(a, b) {\n    return typecheckElementwise(a, b, (a, b) => {\n        if (a.type == \"number\" && b.type == \"number\")\n            return { type: \"number\" };\n        if (a.type == \"point\" && b.type == \"point\")\n            return { type: \"point\" };\n    });\n}\nexport function typecheckBinopMulDiv(a, b) {\n    return typecheckElementwise(a, b, (a, b) => {\n        if (a.type == \"number\" && b.type == \"number\")\n            return { type: \"number\" };\n        if (a.type == \"point\" && b.type == \"point\")\n            return { type: \"point\" };\n        if (a.type == \"number\" && b.type == \"point\")\n            return { type: \"point\" };\n        if (a.type == \"point\" && b.type == \"number\")\n            return { type: \"point\" };\n    });\n}\nexport function typecheckBinopExp(a, b) {\n    return typecheckElementwise(a, b, (a, b) => {\n        if (a.type == \"number\" && b.type == \"number\")\n            return { type: \"number\" };\n    });\n}\nexport function typecheckCompare(a, b) {\n    return typecheckElementwise(a, b, (a, b) => {\n        if (a.type == \"number\" && b.type == \"number\")\n            return { type: \"boolean\" };\n    });\n}\nexport function typecheckLogicOperator(a, b) {\n    return typecheckElementwise(a, b, (a, b) => {\n        if ((a.type == \"number\" || a.type == \"boolean\") &&\n            (b.type == \"number\" || b.type == \"boolean\"))\n            return { type: \"boolean\" };\n    });\n}\nexport function typecheckListSubscript(a, b) {\n    if (a.type != \"list\")\n        return;\n    if (b.type == \"number\")\n        return a.element;\n    if (b.type == \"list\") {\n        if (b.element.type == \"number\" || b.element.type == \"boolean\")\n            return a;\n    }\n}\nexport function consolidateTypeErrors(input) {\n    const errors = input.filter((e) => e.type == \"error\");\n    const err = {\n        type: \"error\",\n        why: errors.map((e) => e.why).flat(),\n    };\n    if (errors.length == 0)\n        return undefined;\n    return err;\n}\nexport function typecheckBinop(expr, ctx) {\n    let lhs = typecheckExpr(expr.lhs, ctx);\n    let rhs = typecheckExpr(expr.rhs, ctx);\n    const err = consolidateTypeErrors([lhs, rhs]);\n    if (err)\n        return err;\n    let result;\n    switch (expr.op) {\n        case \"+\":\n        case \"-\":\n            result = typecheckBinopAddSub(lhs, rhs);\n            break;\n        case \"*\":\n        case \"/\":\n            result = typecheckBinopMulDiv(lhs, rhs);\n            break;\n        case \"^\":\n        case \"%\":\n            result = typecheckBinopExp(lhs, rhs);\n            break;\n        case \"<\":\n        case \"<=\":\n        case \"==\":\n        case \">=\":\n        case \">\":\n            result = typecheckCompare(lhs, rhs);\n            break;\n        case \"&&\":\n        case \"||\":\n            result = typecheckLogicOperator(lhs, rhs);\n            break;\n        case \"[\":\n            result = typecheckListSubscript(lhs, rhs);\n            break;\n        case \"->\":\n            result = { type: \"action\" };\n            break;\n    }\n    if (!result)\n        return wrongTypeError(expr, ctx.unitName, `cannot use operator '${expr.op}' on types '${typeAsStr(lhs)}' and '${typeAsStr(rhs)}'`);\n    return result;\n}\n","import { asExpr, newid, } from \"../ast/ast\";\nimport { formatAST } from \"../ast/fmt\";\nimport { getLinesAndCols } from \"../index\";\nimport { lex } from \"../parse/lex\";\nimport { parse } from \"../parse/parse\";\nexport function macroError(reason, node, unit) {\n    if (typeof reason == \"string\")\n        return {\n            reason,\n            type: \"general\",\n            unit,\n            start: node.start,\n            end: node.end,\n        };\n    return reason;\n}\nexport function mapASTChildren(node, mapper) {\n    function map(n) {\n        // handle arrays within astnodes\n        //@ts-ignore\n        if (Array.isArray(n))\n            return n.map((e) => map(e));\n        //@ts-ignore\n        if (n && typeof n == \"object\" && typeof n.id == \"number\") {\n            // handle current node\n            //@ts-ignore\n            if (n !== node) {\n                //@ts-ignore\n                return mapper(n);\n            }\n            // handle direct child nodes\n            const node2 = n;\n            //@ts-ignore\n            return Object.fromEntries(\n            //@ts-ignore\n            Object.entries(node2).map(([k, v]) => [k, map(v)]));\n        }\n        // handle all other properties\n        //@ts-ignore\n        return n;\n    }\n    //@ts-ignore\n    return { ...map(node), id: newid() };\n}\nexport function getMacroAPI(errors, call, ctx) {\n    const parseStmt = (str) => {\n        const macroSrcName = `_macro${newid()}`;\n        ctx.sourceCode.set(macroSrcName, {\n            src: str,\n            linesAndCols: getLinesAndCols(str),\n        });\n        const lexed = lex(str, macroSrcName, []);\n        //if (!lexed) throw macroError(lexed.data);\n        const ast = parse(lexed, macroSrcName, []);\n        return ast;\n    };\n    function getAbsolutePathRelativeToThisFile(path) {\n        return ctx.io.resolvePath(ctx.io.dirname(ctx.unit), path);\n    }\n    return {\n        //@ts-ignore\n        node: (t) => {\n            return {\n                ...t,\n                id: newid(),\n                start: call.start,\n                end: call.end,\n            };\n        },\n        parse: parseStmt,\n        parseExpr: (str) => {\n            const block = parseStmt(str);\n            if (block.type == \"error\")\n                return block;\n            if (block.type != \"block\" || block.body.length == 0)\n                throw macroError(\"no expression found\", call, ctx.unit);\n            if (block.body.length > 1)\n                throw macroError(\"multiple expressions found; expected only one\", call, ctx.unit);\n            const expr = asExpr(block.body[block.body.length - 1]);\n            if (!expr.success) {\n                throw macroError(\"expected an expression, got a non-expression\", call, ctx.unit);\n            }\n            return expr.data;\n        },\n        fatalError(str) {\n            errors.push(macroError(str, call, ctx.unit));\n            throw \"\";\n        },\n        recoverableError(str) {\n            errors.push(macroError(str, call, ctx.unit));\n        },\n        fmt(ast, ctx) {\n            return formatAST(ast, ctx);\n        },\n        readFile: (path) => {\n            const abspath = getAbsolutePathRelativeToThisFile(path);\n            ctx.watchFiles.add(abspath);\n            return ctx.io.readFile(abspath);\n        },\n        readStringFile: async (filepath) => {\n            const abspath = getAbsolutePathRelativeToThisFile(filepath);\n            ctx.watchFiles.add(abspath);\n            return await ctx.io.readFile(abspath);\n        },\n    };\n}\n","import { newid, } from \"../ast/ast\";\nimport { mapASTChildren } from \"../macro/macro-api\";\nimport { addToScope, } from \"../scope-tree/create-scope-tree\";\nimport { typeAsStr, } from \"../scope-tree/typecheck/typecheck\";\nconst desmosVariables = [\"x\", \"y\", \"t\", \"index\", \"theta\"];\nfunction printOverload(ol) {\n    if (ol.type == \"regular\") {\n        return `(${ol.params\n            .map((param) => {\n            return param\n                .map((p, i) => ol.requiredCount !== undefined && i >= ol.requiredCount\n                ? `[${typeAsStr(p)}]`\n                : typeAsStr(p))\n                .join(\" | \");\n        })\n            .join(\", \")}) -> ${typeAsStr(ol.returns)}`;\n    }\n    else {\n        const param = ol.validTypes.map((vt) => typeAsStr(vt)).join(\" | \");\n        return `(${ol.minArgs ? `${new Array(ol.minArgs).fill(param).join(\", \")}, ` : \"\"}...${ol.validTypes.length > 1 ? \"(\" : \"\"}${param}${ol.validTypes.length > 1 ? \")\" : \"\"}[]) -> ${typeAsStr(ol.returns)}`;\n    }\n}\nexport function printTypeSig(sig) {\n    return sig.map((o) => printOverload(o)).join(\"\\n\");\n}\n// represents a function that takes a variable number of numbers\n// with the QoL feature of taking either lists or numbers\nconst variadicOf = (t, ret) => [\n    // number[] -> number\n    {\n        type: \"regular\",\n        params: [[{ type: \"list\", element: t }]],\n        returns: ret ?? t,\n    },\n    // ...number -> number\n    {\n        type: \"variadic\",\n        validTypes: [t],\n        returns: ret ?? t,\n    },\n    // ...(number | number[]) -> number[]\n    {\n        type: \"variadic\",\n        validTypes: [t, { type: \"list\", element: t }],\n        returns: { type: \"list\", element: ret ?? t },\n    },\n];\n// function that takes a specific number of numbers\nconst nNumbers = (n) => [\n    {\n        type: \"regular\",\n        params: new Array(n).fill(0).map((e) => [{ type: \"number\" }]),\n        returns: { type: \"number\" },\n    },\n    {\n        type: \"regular\",\n        params: new Array(n)\n            .fill(0)\n            .map((e) => [\n            { type: \"number\" },\n            { type: \"list\", element: { type: \"number\" } },\n        ]),\n        returns: listof({ type: \"number\" }),\n    },\n];\nconst listof = (t) => {\n    return { type: \"list\", element: t };\n};\nconst statisticalFunctionWithDistribution = [\n    {\n        type: \"regular\",\n        params: [[{ type: \"distribution\" }]],\n        returns: { type: \"distribution\" },\n    },\n    {\n        type: \"regular\",\n        params: [[listof({ type: \"distribution\" })]],\n        returns: listof({ type: \"distribution\" }),\n    },\n];\nconst primitives = [\n    { type: \"number\" },\n    { type: \"polygon\" },\n    { type: \"color\" },\n    { type: \"point\" },\n];\nconst numberOrNumberList = [\n    { type: \"number\" },\n    listof({ type: \"number\" }),\n];\nconst desmosFunctions = [\n    ...[\"min\", \"max\", \"stdev\", \"mean\", \"median\"].map((e) => [\n        e,\n        [\n            ...variadicOf({ type: \"number\" }),\n            ...statisticalFunctionWithDistribution,\n        ],\n    ]),\n    [\n        \"normaldist\",\n        [\n            {\n                type: \"regular\",\n                params: [numberOrNumberList, numberOrNumberList],\n                returns: { type: \"distribution\" },\n                requiredCount: 0,\n            },\n        ],\n    ],\n    [\n        \"uniformdist\",\n        [\n            {\n                type: \"regular\",\n                params: [numberOrNumberList, numberOrNumberList],\n                returns: { type: \"distribution\" },\n                requiredCount: 0,\n            },\n        ],\n    ],\n    [\n        \"binomialdist\",\n        [\n            {\n                type: \"regular\",\n                params: [numberOrNumberList, numberOrNumberList],\n                returns: { type: \"distribution\" },\n                requiredCount: 1,\n            },\n        ],\n    ],\n    ...[\n        \"sin\",\n        \"cos\",\n        \"tan\",\n        \"csc\",\n        \"sec\",\n        \"cot\",\n        \"arcsin\",\n        \"arccos\",\n        \"arccsc\",\n        \"arcsec\",\n        \"arccot\",\n        \"sinh\",\n        \"cosh\",\n        \"tanh\",\n        \"csch\",\n        \"sech\",\n        \"coth\",\n        \"floor\",\n        \"ceil\",\n        \"round\",\n    ].map((e) => [e, nNumbers(1)]),\n    [\"arctan\", [...nNumbers(1), ...nNumbers(2)]],\n    [\"mod\", nNumbers(2)],\n    [\n        \"join\",\n        //...(T | T[]) -> T\n        primitives.map((p) => {\n            return {\n                type: \"variadic\",\n                minArgs: 2,\n                validTypes: [p, listof(p)],\n                returns: listof(p),\n            };\n        }),\n    ],\n    [\n        \"sort\",\n        primitives.map((p) => {\n            return {\n                type: \"regular\",\n                params: [[listof(p)], [listof({ type: \"number\" })]],\n                returns: listof(p),\n                requiredCount: 1,\n            };\n        }),\n    ],\n    [\n        \"unique\",\n        primitives.map((p) => {\n            return {\n                type: \"regular\",\n                params: [[listof(p)]],\n                returns: listof(p),\n            };\n        }),\n    ],\n    [\n        \"polygon\",\n        [\n            ...variadicOf({ type: \"point\" }, { type: \"polygon\" }),\n            {\n                type: \"regular\",\n                params: [[listof({ type: \"number\" })], [listof({ type: \"number\" })]],\n                returns: { type: \"number\" },\n            },\n        ],\n    ],\n    [\n        \"distance\",\n        [\n            {\n                type: \"regular\",\n                params: [[{ type: \"point\" }], [{ type: \"point\" }]],\n                returns: { type: \"number\" },\n            },\n            {\n                type: \"regular\",\n                params: [\n                    [{ type: \"point\" }, listof({ type: \"point\" })],\n                    [{ type: \"point\" }, listof({ type: \"point\" })],\n                ],\n                returns: listof({ type: \"number\" }),\n            },\n        ],\n    ],\n    ...[\"rgb\", \"hsv\"].map((f) => [\n        f,\n        [\n            {\n                type: \"regular\",\n                params: new Array(3)\n                    .fill(0)\n                    .map((e) => [{ type: \"number\" }]),\n                returns: { type: \"color\" },\n            },\n            {\n                type: \"regular\",\n                params: new Array(3)\n                    .fill(0)\n                    .map((e) => [\n                    { type: \"number\" },\n                    listof({ type: \"number\" }),\n                ]),\n                returns: listof({ type: \"color\" }),\n            },\n        ],\n    ]),\n    [\n        \"random\",\n        [\n            // operands with input list\n            ...primitives\n                .map((p) => [\n                {\n                    type: \"regular\",\n                    params: [[listof(p)]],\n                    returns: p,\n                },\n                {\n                    type: \"regular\",\n                    params: [\n                        [listof(p)],\n                        [{ type: \"number\" }],\n                        [{ type: \"number\" }],\n                    ],\n                    returns: listof(p),\n                    requiredCount: 2,\n                },\n            ])\n                .flat(1),\n            // operands without input list\n            {\n                type: \"regular\",\n                params: [],\n                returns: { type: \"number\" },\n            },\n            {\n                type: \"regular\",\n                params: [[{ type: \"number\" }], [{ type: \"number\" }]],\n                returns: listof({ type: \"number\" }),\n            },\n        ],\n    ],\n    [\n        \"shuffle\",\n        primitives\n            .map((p) => [\n            {\n                type: \"regular\",\n                params: [[listof(p)], [{ type: \"number\" }]],\n                returns: listof(p),\n                requiredCount: 1,\n            },\n        ])\n            .flat(1),\n    ],\n];\nexport function addStdlibToScope(scope, ctx) {\n    for (const [fname, typesig] of desmosFunctions) {\n        addToScope(scope, fname, {\n            type: \"builtin-function\",\n            typeSignature: typesig,\n            id: newid(),\n            definedByDesmos: true,\n            unitName: \"\",\n        }, ctx.errors);\n    }\n    for (const vname of desmosVariables) {\n        addToScope(scope, vname, {\n            type: \"builtin-variable\",\n            id: newid(),\n            definedByDesmos: true,\n            unitName: \"\",\n            typeSignature: { type: \"number\" },\n        }, ctx.errors);\n    }\n    addToScope(scope, \"five\", {\n        type: \"macro\",\n        id: newid(),\n        unitName: \"\",\n        macroOperation: async (node, a) => {\n            // return {\n            //   type: \"number\",\n            //   number: 5,\n            //   start: node.start,\n            //   end: node.end,\n            //   id: newid(),\n            // };\n            return a.parseExpr(\"1 + 696969   42042042 + 1 + 1\");\n        },\n    }, ctx.errors);\n    addToScope(scope, \"loadcsv\", {\n        type: \"macro\",\n        id: newid(),\n        unitName: \"\",\n        macroOperation: async (node, a) => {\n            const param1 = node.params[0];\n            if (node.params.length != 1)\n                a.fatalError(\"expected exactly 1 parameter representing the csv file name\");\n            if (param1.type != \"note\")\n                a.fatalError(\"expected a string\");\n            const contents = await a.readStringFile(param1.content);\n            return a.parseExpr(`[${contents}]`);\n        },\n    }, ctx.errors);\n    addToScope(scope, \"loop\", {\n        type: \"macro\",\n        id: newid(),\n        unitName: \"\",\n        macroOperation: async (node, a) => {\n            if (node.params.length != 4)\n                a.fatalError(\"Expected exactly 3 parameters.\");\n            const nsnameNode = node.params[0];\n            const iterationsNode = node.params[1];\n            if (nsnameNode.type != \"identifier\" || nsnameNode.segments.length != 1)\n                a.fatalError(\"Expected parameter 1 to be an identifier with 1 segment.\");\n            if (iterationsNode.type != \"number\" ||\n                iterationsNode.number != Math.round(iterationsNode.number))\n                a.fatalError(\"Expected parameter 3 to be an integer.\");\n            const nsname = nsnameNode.segments[0];\n            const iterations = iterationsNode.number;\n            if (node.params[2].type != \"block\")\n                a.fatalError(\"expected parameter 3 to be a block\");\n            if (node.params[3].type != \"block\")\n                a.fatalError(\"expected parameter 4 to be a block\");\n            function processLoopBody(node, itername) {\n                const cb = (n) => processLoopBody(n, itername);\n                if (node.type == \"identifier\") {\n                    return mapASTChildren({\n                        ...node,\n                        segments: [\n                            node.segments[0] == \"prev\" ? itername : node.segments[0],\n                            ...node.segments.slice(1),\n                        ],\n                    }, cb);\n                }\n                return mapASTChildren(node, cb);\n            }\n            function copyNode(node) {\n                return mapASTChildren(node, copyNode);\n            }\n            const getIterName = (i) => (i == -1 ? \"init\" : `iter${i}`);\n            return a.node({\n                type: \"namespace\",\n                name: nsname,\n                body: a.node({\n                    type: \"block\",\n                    body: [\n                        a.node({\n                            type: \"namespace\",\n                            name: \"init\",\n                            body: copyNode(node.params[2]),\n                        }),\n                        ...new Array(Math.max(iterations - 1, 0)).fill(0).map((e, i) => {\n                            return a.node({\n                                type: \"namespace\",\n                                name: `iter${i}`,\n                                body: processLoopBody(node.params[3], getIterName(i - 1)),\n                            });\n                        }),\n                        ...processLoopBody(node.params[3], getIterName(iterations - 2)).body,\n                    ],\n                }),\n            });\n        },\n    }, ctx.errors);\n    //loop!(nsname, last, init, body)\n    addToScope(scope, \"subst\", {\n        type: \"macro\",\n        id: newid(),\n        unitName: \"\",\n        macroOperation: async (node, a) => {\n            const params = node.params;\n            if (params.length < 2)\n                a.fatalError(\"Expected at least two arguments: a macro name, zero or more macro parameters, and a macro body expression\");\n            const name = params[0];\n            const argmap = new Map();\n            let i = 0;\n            for (const param of params.slice(0, -1)) {\n                if (param.type != \"identifier\" || param.segments.length != 1)\n                    a.fatalError(\"Expected a variable name for every argument except the last.\");\n                if (i > 0)\n                    if (param.type == \"identifier\")\n                        argmap.set(param.segments[0], i - 1);\n                i++;\n            }\n            addToScope(node.enclosingScope, name.segments[0], {\n                type: \"macro\",\n                id: newid(),\n                unitName: \"\",\n                macroOperation: async (node, a) => {\n                    const args = node.params;\n                    function process(node) {\n                        if (node.type == \"identifier\" && node.segments.length == 1) {\n                            const argIndex = argmap.get(node.segments[0]);\n                            if (argIndex !== undefined) {\n                                return mapASTChildren(args[argIndex], process);\n                            }\n                        }\n                        return mapASTChildren(node, process);\n                    }\n                    const out = process(params[params.length - 1]);\n                    return out;\n                },\n            }, ctx.errors);\n            return a.node({ type: \"number\", number: 0 });\n        },\n    }, ctx.errors);\n}\n","var util;\n(function (util) {\n    util.assertEqual = (val) => val;\n    function assertIs(_arg) { }\n    util.assertIs = assertIs;\n    function assertNever(_x) {\n        throw new Error();\n    }\n    util.assertNever = assertNever;\n    util.arrayToEnum = (items) => {\n        const obj = {};\n        for (const item of items) {\n            obj[item] = item;\n        }\n        return obj;\n    };\n    util.getValidEnumValues = (obj) => {\n        const validKeys = util.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== \"number\");\n        const filtered = {};\n        for (const k of validKeys) {\n            filtered[k] = obj[k];\n        }\n        return util.objectValues(filtered);\n    };\n    util.objectValues = (obj) => {\n        return util.objectKeys(obj).map(function (e) {\n            return obj[e];\n        });\n    };\n    util.objectKeys = typeof Object.keys === \"function\" // eslint-disable-line ban/ban\n        ? (obj) => Object.keys(obj) // eslint-disable-line ban/ban\n        : (object) => {\n            const keys = [];\n            for (const key in object) {\n                if (Object.prototype.hasOwnProperty.call(object, key)) {\n                    keys.push(key);\n                }\n            }\n            return keys;\n        };\n    util.find = (arr, checker) => {\n        for (const item of arr) {\n            if (checker(item))\n                return item;\n        }\n        return undefined;\n    };\n    util.isInteger = typeof Number.isInteger === \"function\"\n        ? (val) => Number.isInteger(val) // eslint-disable-line ban/ban\n        : (val) => typeof val === \"number\" && isFinite(val) && Math.floor(val) === val;\n    function joinValues(array, separator = \" | \") {\n        return array\n            .map((val) => (typeof val === \"string\" ? `'${val}'` : val))\n            .join(separator);\n    }\n    util.joinValues = joinValues;\n    util.jsonStringifyReplacer = (_, value) => {\n        if (typeof value === \"bigint\") {\n            return value.toString();\n        }\n        return value;\n    };\n})(util || (util = {}));\nconst ZodParsedType = util.arrayToEnum([\n    \"string\",\n    \"nan\",\n    \"number\",\n    \"integer\",\n    \"float\",\n    \"boolean\",\n    \"date\",\n    \"bigint\",\n    \"symbol\",\n    \"function\",\n    \"undefined\",\n    \"null\",\n    \"array\",\n    \"object\",\n    \"unknown\",\n    \"promise\",\n    \"void\",\n    \"never\",\n    \"map\",\n    \"set\",\n]);\nconst getParsedType = (data) => {\n    const t = typeof data;\n    switch (t) {\n        case \"undefined\":\n            return ZodParsedType.undefined;\n        case \"string\":\n            return ZodParsedType.string;\n        case \"number\":\n            return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;\n        case \"boolean\":\n            return ZodParsedType.boolean;\n        case \"function\":\n            return ZodParsedType.function;\n        case \"bigint\":\n            return ZodParsedType.bigint;\n        case \"symbol\":\n            return ZodParsedType.symbol;\n        case \"object\":\n            if (Array.isArray(data)) {\n                return ZodParsedType.array;\n            }\n            if (data === null) {\n                return ZodParsedType.null;\n            }\n            if (data.then &&\n                typeof data.then === \"function\" &&\n                data.catch &&\n                typeof data.catch === \"function\") {\n                return ZodParsedType.promise;\n            }\n            if (typeof Map !== \"undefined\" && data instanceof Map) {\n                return ZodParsedType.map;\n            }\n            if (typeof Set !== \"undefined\" && data instanceof Set) {\n                return ZodParsedType.set;\n            }\n            if (typeof Date !== \"undefined\" && data instanceof Date) {\n                return ZodParsedType.date;\n            }\n            return ZodParsedType.object;\n        default:\n            return ZodParsedType.unknown;\n    }\n};\n\nconst ZodIssueCode = util.arrayToEnum([\n    \"invalid_type\",\n    \"invalid_literal\",\n    \"custom\",\n    \"invalid_union\",\n    \"invalid_union_discriminator\",\n    \"invalid_enum_value\",\n    \"unrecognized_keys\",\n    \"invalid_arguments\",\n    \"invalid_return_type\",\n    \"invalid_date\",\n    \"invalid_string\",\n    \"too_small\",\n    \"too_big\",\n    \"invalid_intersection_types\",\n    \"not_multiple_of\",\n    \"not_finite\",\n]);\nconst quotelessJson = (obj) => {\n    const json = JSON.stringify(obj, null, 2);\n    return json.replace(/\"([^\"]+)\":/g, \"$1:\");\n};\nclass ZodError extends Error {\n    constructor(issues) {\n        super();\n        this.issues = [];\n        this.addIssue = (sub) => {\n            this.issues = [...this.issues, sub];\n        };\n        this.addIssues = (subs = []) => {\n            this.issues = [...this.issues, ...subs];\n        };\n        const actualProto = new.target.prototype;\n        if (Object.setPrototypeOf) {\n            // eslint-disable-next-line ban/ban\n            Object.setPrototypeOf(this, actualProto);\n        }\n        else {\n            this.__proto__ = actualProto;\n        }\n        this.name = \"ZodError\";\n        this.issues = issues;\n    }\n    get errors() {\n        return this.issues;\n    }\n    format(_mapper) {\n        const mapper = _mapper ||\n            function (issue) {\n                return issue.message;\n            };\n        const fieldErrors = { _errors: [] };\n        const processError = (error) => {\n            for (const issue of error.issues) {\n                if (issue.code === \"invalid_union\") {\n                    issue.unionErrors.map(processError);\n                }\n                else if (issue.code === \"invalid_return_type\") {\n                    processError(issue.returnTypeError);\n                }\n                else if (issue.code === \"invalid_arguments\") {\n                    processError(issue.argumentsError);\n                }\n                else if (issue.path.length === 0) {\n                    fieldErrors._errors.push(mapper(issue));\n                }\n                else {\n                    let curr = fieldErrors;\n                    let i = 0;\n                    while (i < issue.path.length) {\n                        const el = issue.path[i];\n                        const terminal = i === issue.path.length - 1;\n                        if (!terminal) {\n                            curr[el] = curr[el] || { _errors: [] };\n                            // if (typeof el === \"string\") {\n                            //   curr[el] = curr[el] || { _errors: [] };\n                            // } else if (typeof el === \"number\") {\n                            //   const errorArray: any = [];\n                            //   errorArray._errors = [];\n                            //   curr[el] = curr[el] || errorArray;\n                            // }\n                        }\n                        else {\n                            curr[el] = curr[el] || { _errors: [] };\n                            curr[el]._errors.push(mapper(issue));\n                        }\n                        curr = curr[el];\n                        i++;\n                    }\n                }\n            }\n        };\n        processError(this);\n        return fieldErrors;\n    }\n    toString() {\n        return this.message;\n    }\n    get message() {\n        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);\n    }\n    get isEmpty() {\n        return this.issues.length === 0;\n    }\n    flatten(mapper = (issue) => issue.message) {\n        const fieldErrors = {};\n        const formErrors = [];\n        for (const sub of this.issues) {\n            if (sub.path.length > 0) {\n                fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n                fieldErrors[sub.path[0]].push(mapper(sub));\n            }\n            else {\n                formErrors.push(mapper(sub));\n            }\n        }\n        return { formErrors, fieldErrors };\n    }\n    get formErrors() {\n        return this.flatten();\n    }\n}\nZodError.create = (issues) => {\n    const error = new ZodError(issues);\n    return error;\n};\n\nconst errorMap = (issue, _ctx) => {\n    let message;\n    switch (issue.code) {\n        case ZodIssueCode.invalid_type:\n            if (issue.received === ZodParsedType.undefined) {\n                message = \"Required\";\n            }\n            else {\n                message = `Expected ${issue.expected}, received ${issue.received}`;\n            }\n            break;\n        case ZodIssueCode.invalid_literal:\n            message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;\n            break;\n        case ZodIssueCode.unrecognized_keys:\n            message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, \", \")}`;\n            break;\n        case ZodIssueCode.invalid_union:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_union_discriminator:\n            message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;\n            break;\n        case ZodIssueCode.invalid_enum_value:\n            message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;\n            break;\n        case ZodIssueCode.invalid_arguments:\n            message = `Invalid function arguments`;\n            break;\n        case ZodIssueCode.invalid_return_type:\n            message = `Invalid function return type`;\n            break;\n        case ZodIssueCode.invalid_date:\n            message = `Invalid date`;\n            break;\n        case ZodIssueCode.invalid_string:\n            if (typeof issue.validation === \"object\") {\n                if (\"startsWith\" in issue.validation) {\n                    message = `Invalid input: must start with \"${issue.validation.startsWith}\"`;\n                }\n                else if (\"endsWith\" in issue.validation) {\n                    message = `Invalid input: must end with \"${issue.validation.endsWith}\"`;\n                }\n                else {\n                    util.assertNever(issue.validation);\n                }\n            }\n            else if (issue.validation !== \"regex\") {\n                message = `Invalid ${issue.validation}`;\n            }\n            else {\n                message = \"Invalid\";\n            }\n            break;\n        case ZodIssueCode.too_small:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? \"exactly\" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${issue.minimum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly equal to `\n                    : issue.inclusive\n                        ? `greater than or equal to `\n                        : `greater than `}${new Date(issue.minimum)}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.too_big:\n            if (issue.type === \"array\")\n                message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;\n            else if (issue.type === \"string\")\n                message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;\n            else if (issue.type === \"number\")\n                message = `Number must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `less than or equal to`\n                        : `less than`} ${issue.maximum}`;\n            else if (issue.type === \"date\")\n                message = `Date must be ${issue.exact\n                    ? `exactly`\n                    : issue.inclusive\n                        ? `smaller than or equal to`\n                        : `smaller than`} ${new Date(issue.maximum)}`;\n            else\n                message = \"Invalid input\";\n            break;\n        case ZodIssueCode.custom:\n            message = `Invalid input`;\n            break;\n        case ZodIssueCode.invalid_intersection_types:\n            message = `Intersection results could not be merged`;\n            break;\n        case ZodIssueCode.not_multiple_of:\n            message = `Number must be a multiple of ${issue.multipleOf}`;\n            break;\n        case ZodIssueCode.not_finite:\n            message = \"Number must be finite\";\n            break;\n        default:\n            message = _ctx.defaultError;\n            util.assertNever(issue);\n    }\n    return { message };\n};\n\nlet overrideErrorMap = errorMap;\nfunction setErrorMap(map) {\n    overrideErrorMap = map;\n}\nfunction getErrorMap() {\n    return overrideErrorMap;\n}\n\nconst makeIssue = (params) => {\n    const { data, path, errorMaps, issueData } = params;\n    const fullPath = [...path, ...(issueData.path || [])];\n    const fullIssue = {\n        ...issueData,\n        path: fullPath,\n    };\n    let errorMessage = \"\";\n    const maps = errorMaps\n        .filter((m) => !!m)\n        .slice()\n        .reverse();\n    for (const map of maps) {\n        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;\n    }\n    return {\n        ...issueData,\n        path: fullPath,\n        message: issueData.message || errorMessage,\n    };\n};\nconst EMPTY_PATH = [];\nfunction addIssueToContext(ctx, issueData) {\n    const issue = makeIssue({\n        issueData: issueData,\n        data: ctx.data,\n        path: ctx.path,\n        errorMaps: [\n            ctx.common.contextualErrorMap,\n            ctx.schemaErrorMap,\n            getErrorMap(),\n            errorMap, // then global default map\n        ].filter((x) => !!x),\n    });\n    ctx.common.issues.push(issue);\n}\nclass ParseStatus {\n    constructor() {\n        this.value = \"valid\";\n    }\n    dirty() {\n        if (this.value === \"valid\")\n            this.value = \"dirty\";\n    }\n    abort() {\n        if (this.value !== \"aborted\")\n            this.value = \"aborted\";\n    }\n    static mergeArray(status, results) {\n        const arrayValue = [];\n        for (const s of results) {\n            if (s.status === \"aborted\")\n                return INVALID;\n            if (s.status === \"dirty\")\n                status.dirty();\n            arrayValue.push(s.value);\n        }\n        return { status: status.value, value: arrayValue };\n    }\n    static async mergeObjectAsync(status, pairs) {\n        const syncPairs = [];\n        for (const pair of pairs) {\n            syncPairs.push({\n                key: await pair.key,\n                value: await pair.value,\n            });\n        }\n        return ParseStatus.mergeObjectSync(status, syncPairs);\n    }\n    static mergeObjectSync(status, pairs) {\n        const finalObject = {};\n        for (const pair of pairs) {\n            const { key, value } = pair;\n            if (key.status === \"aborted\")\n                return INVALID;\n            if (value.status === \"aborted\")\n                return INVALID;\n            if (key.status === \"dirty\")\n                status.dirty();\n            if (value.status === \"dirty\")\n                status.dirty();\n            if (typeof value.value !== \"undefined\" || pair.alwaysSet) {\n                finalObject[key.value] = value.value;\n            }\n        }\n        return { status: status.value, value: finalObject };\n    }\n}\nconst INVALID = Object.freeze({\n    status: \"aborted\",\n});\nconst DIRTY = (value) => ({ status: \"dirty\", value });\nconst OK = (value) => ({ status: \"valid\", value });\nconst isAborted = (x) => x.status === \"aborted\";\nconst isDirty = (x) => x.status === \"dirty\";\nconst isValid = (x) => x.status === \"valid\";\nconst isAsync = (x) => typeof Promise !== undefined && x instanceof Promise;\n\nvar errorUtil;\n(function (errorUtil) {\n    errorUtil.errToObj = (message) => typeof message === \"string\" ? { message } : message || {};\n    errorUtil.toString = (message) => typeof message === \"string\" ? message : message === null || message === void 0 ? void 0 : message.message;\n})(errorUtil || (errorUtil = {}));\n\nclass ParseInputLazyPath {\n    constructor(parent, value, path, key) {\n        this.parent = parent;\n        this.data = value;\n        this._path = path;\n        this._key = key;\n    }\n    get path() {\n        return this._path.concat(this._key);\n    }\n}\nconst handleResult = (ctx, result) => {\n    if (isValid(result)) {\n        return { success: true, data: result.value };\n    }\n    else {\n        if (!ctx.common.issues.length) {\n            throw new Error(\"Validation failed but no issues detected.\");\n        }\n        const error = new ZodError(ctx.common.issues);\n        return { success: false, error };\n    }\n};\nfunction processCreateParams(params) {\n    if (!params)\n        return {};\n    const { errorMap, invalid_type_error, required_error, description } = params;\n    if (errorMap && (invalid_type_error || required_error)) {\n        throw new Error(`Can't use \"invalid_type_error\" or \"required_error\" in conjunction with custom error map.`);\n    }\n    if (errorMap)\n        return { errorMap: errorMap, description };\n    const customMap = (iss, ctx) => {\n        if (iss.code !== \"invalid_type\")\n            return { message: ctx.defaultError };\n        if (typeof ctx.data === \"undefined\") {\n            return { message: required_error !== null && required_error !== void 0 ? required_error : ctx.defaultError };\n        }\n        return { message: invalid_type_error !== null && invalid_type_error !== void 0 ? invalid_type_error : ctx.defaultError };\n    };\n    return { errorMap: customMap, description };\n}\nclass ZodType {\n    constructor(def) {\n        /** Alias of safeParseAsync */\n        this.spa = this.safeParseAsync;\n        this._def = def;\n        this.parse = this.parse.bind(this);\n        this.safeParse = this.safeParse.bind(this);\n        this.parseAsync = this.parseAsync.bind(this);\n        this.safeParseAsync = this.safeParseAsync.bind(this);\n        this.spa = this.spa.bind(this);\n        this.refine = this.refine.bind(this);\n        this.refinement = this.refinement.bind(this);\n        this.superRefine = this.superRefine.bind(this);\n        this.optional = this.optional.bind(this);\n        this.nullable = this.nullable.bind(this);\n        this.nullish = this.nullish.bind(this);\n        this.array = this.array.bind(this);\n        this.promise = this.promise.bind(this);\n        this.or = this.or.bind(this);\n        this.and = this.and.bind(this);\n        this.transform = this.transform.bind(this);\n        this.brand = this.brand.bind(this);\n        this.default = this.default.bind(this);\n        this.catch = this.catch.bind(this);\n        this.describe = this.describe.bind(this);\n        this.pipe = this.pipe.bind(this);\n        this.isNullable = this.isNullable.bind(this);\n        this.isOptional = this.isOptional.bind(this);\n    }\n    get description() {\n        return this._def.description;\n    }\n    _getType(input) {\n        return getParsedType(input.data);\n    }\n    _getOrReturnCtx(input, ctx) {\n        return (ctx || {\n            common: input.parent.common,\n            data: input.data,\n            parsedType: getParsedType(input.data),\n            schemaErrorMap: this._def.errorMap,\n            path: input.path,\n            parent: input.parent,\n        });\n    }\n    _processInputParams(input) {\n        return {\n            status: new ParseStatus(),\n            ctx: {\n                common: input.parent.common,\n                data: input.data,\n                parsedType: getParsedType(input.data),\n                schemaErrorMap: this._def.errorMap,\n                path: input.path,\n                parent: input.parent,\n            },\n        };\n    }\n    _parseSync(input) {\n        const result = this._parse(input);\n        if (isAsync(result)) {\n            throw new Error(\"Synchronous parse encountered promise.\");\n        }\n        return result;\n    }\n    _parseAsync(input) {\n        const result = this._parse(input);\n        return Promise.resolve(result);\n    }\n    parse(data, params) {\n        const result = this.safeParse(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    safeParse(data, params) {\n        var _a;\n        const ctx = {\n            common: {\n                issues: [],\n                async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const result = this._parseSync({ data, path: ctx.path, parent: ctx });\n        return handleResult(ctx, result);\n    }\n    async parseAsync(data, params) {\n        const result = await this.safeParseAsync(data, params);\n        if (result.success)\n            return result.data;\n        throw result.error;\n    }\n    async safeParseAsync(data, params) {\n        const ctx = {\n            common: {\n                issues: [],\n                contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,\n                async: true,\n            },\n            path: (params === null || params === void 0 ? void 0 : params.path) || [],\n            schemaErrorMap: this._def.errorMap,\n            parent: null,\n            data,\n            parsedType: getParsedType(data),\n        };\n        const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });\n        const result = await (isAsync(maybeAsyncResult)\n            ? maybeAsyncResult\n            : Promise.resolve(maybeAsyncResult));\n        return handleResult(ctx, result);\n    }\n    refine(check, message) {\n        const getIssueProperties = (val) => {\n            if (typeof message === \"string\" || typeof message === \"undefined\") {\n                return { message };\n            }\n            else if (typeof message === \"function\") {\n                return message(val);\n            }\n            else {\n                return message;\n            }\n        };\n        return this._refinement((val, ctx) => {\n            const result = check(val);\n            const setError = () => ctx.addIssue({\n                code: ZodIssueCode.custom,\n                ...getIssueProperties(val),\n            });\n            if (typeof Promise !== \"undefined\" && result instanceof Promise) {\n                return result.then((data) => {\n                    if (!data) {\n                        setError();\n                        return false;\n                    }\n                    else {\n                        return true;\n                    }\n                });\n            }\n            if (!result) {\n                setError();\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    refinement(check, refinementData) {\n        return this._refinement((val, ctx) => {\n            if (!check(val)) {\n                ctx.addIssue(typeof refinementData === \"function\"\n                    ? refinementData(val, ctx)\n                    : refinementData);\n                return false;\n            }\n            else {\n                return true;\n            }\n        });\n    }\n    _refinement(refinement) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"refinement\", refinement },\n        });\n    }\n    superRefine(refinement) {\n        return this._refinement(refinement);\n    }\n    optional() {\n        return ZodOptional.create(this);\n    }\n    nullable() {\n        return ZodNullable.create(this);\n    }\n    nullish() {\n        return this.optional().nullable();\n    }\n    array() {\n        return ZodArray.create(this);\n    }\n    promise() {\n        return ZodPromise.create(this);\n    }\n    or(option) {\n        return ZodUnion.create([this, option]);\n    }\n    and(incoming) {\n        return ZodIntersection.create(this, incoming);\n    }\n    transform(transform) {\n        return new ZodEffects({\n            schema: this,\n            typeName: ZodFirstPartyTypeKind.ZodEffects,\n            effect: { type: \"transform\", transform },\n        });\n    }\n    default(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodDefault({\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodDefault,\n        });\n    }\n    brand() {\n        return new ZodBranded({\n            typeName: ZodFirstPartyTypeKind.ZodBranded,\n            type: this,\n            ...processCreateParams(undefined),\n        });\n    }\n    catch(def) {\n        const defaultValueFunc = typeof def === \"function\" ? def : () => def;\n        return new ZodCatch({\n            innerType: this,\n            defaultValue: defaultValueFunc,\n            typeName: ZodFirstPartyTypeKind.ZodCatch,\n        });\n    }\n    describe(description) {\n        const This = this.constructor;\n        return new This({\n            ...this._def,\n            description,\n        });\n    }\n    pipe(target) {\n        return ZodPipeline.create(this, target);\n    }\n    isOptional() {\n        return this.safeParse(undefined).success;\n    }\n    isNullable() {\n        return this.safeParse(null).success;\n    }\n}\nconst cuidRegex = /^c[^\\s-]{8,}$/i;\nconst uuidRegex = /^([a-f0-9]{8}-[a-f0-9]{4}-[1-5][a-f0-9]{3}-[a-f0-9]{4}-[a-f0-9]{12}|00000000-0000-0000-0000-000000000000)$/i;\n// from https://stackoverflow.com/a/46181/1550155\n// old version: too slow, didn't support unicode\n// const emailRegex = /^((([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+(\\.([a-z]|\\d|[!#\\$%&'\\*\\+\\-\\/=\\?\\^_`{\\|}~]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])+)*)|((\\x22)((((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(([\\x01-\\x08\\x0b\\x0c\\x0e-\\x1f\\x7f]|\\x21|[\\x23-\\x5b]|[\\x5d-\\x7e]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(\\\\([\\x01-\\x09\\x0b\\x0c\\x0d-\\x7f]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]))))*(((\\x20|\\x09)*(\\x0d\\x0a))?(\\x20|\\x09)+)?(\\x22)))@((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))$/i;\n// eslint-disable-next-line\nconst emailRegex = /^(([^<>()[\\]\\.,;:\\s@\\\"]+(\\.[^<>()[\\]\\.,;:\\s@\\\"]+)*)|(\\\".+\\\"))@(([^<>()[\\]\\.,;:\\s@\\\"]+\\.)+[^<>()[\\]\\.,;:\\s@\\\"]{2,})$/i;\n// interface IsDateStringOptions extends StringDateOptions {\n/**\n * Match any configuration\n */\n// any?: boolean;\n// }\n// Adapted from https://stackoverflow.com/a/3143231\nconst datetimeRegex = (args) => {\n    if (args.precision) {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}(([+-]\\\\d{2}:\\\\d{2})|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}\\\\.\\\\d{${args.precision}}Z$`);\n        }\n    }\n    else if (args.precision === 0) {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(([+-]\\\\d{2}:\\\\d{2})|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}Z$`);\n        }\n    }\n    else {\n        if (args.offset) {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?(([+-]\\\\d{2}:\\\\d{2})|Z)$`);\n        }\n        else {\n            return new RegExp(`^\\\\d{4}-\\\\d{2}-\\\\d{2}T\\\\d{2}:\\\\d{2}:\\\\d{2}(\\\\.\\\\d+)?Z$`);\n        }\n    }\n};\nclass ZodString extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._regex = (regex, validation, message) => this.refinement((data) => regex.test(data), {\n            validation,\n            code: ZodIssueCode.invalid_string,\n            ...errorUtil.errToObj(message),\n        });\n        /**\n         * @deprecated Use z.string().min(1) instead.\n         * @see {@link ZodString.min}\n         */\n        this.nonempty = (message) => this.min(1, errorUtil.errToObj(message));\n        this.trim = () => new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, { kind: \"trim\" }],\n        });\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = String(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.string) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.string,\n                received: ctx.parsedType,\n            }\n            //\n            );\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.length < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.length > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"string\",\n                        inclusive: true,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"length\") {\n                const tooBig = input.data.length > check.value;\n                const tooSmall = input.data.length < check.value;\n                if (tooBig || tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    if (tooBig) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_big,\n                            maximum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    else if (tooSmall) {\n                        addIssueToContext(ctx, {\n                            code: ZodIssueCode.too_small,\n                            minimum: check.value,\n                            type: \"string\",\n                            inclusive: true,\n                            exact: true,\n                            message: check.message,\n                        });\n                    }\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"email\") {\n                if (!emailRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"email\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"uuid\") {\n                if (!uuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"uuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"cuid\") {\n                if (!cuidRegex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"cuid\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"url\") {\n                try {\n                    new URL(input.data);\n                }\n                catch (_a) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"url\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"regex\") {\n                check.regex.lastIndex = 0;\n                const testResult = check.regex.test(input.data);\n                if (!testResult) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        validation: \"regex\",\n                        code: ZodIssueCode.invalid_string,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"trim\") {\n                input.data = input.data.trim();\n            }\n            else if (check.kind === \"startsWith\") {\n                if (!input.data.startsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { startsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"endsWith\") {\n                if (!input.data.endsWith(check.value)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: { endsWith: check.value },\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"datetime\") {\n                const regex = datetimeRegex(check);\n                if (!regex.test(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_string,\n                        validation: \"datetime\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    _addCheck(check) {\n        return new ZodString({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    email(message) {\n        return this._addCheck({ kind: \"email\", ...errorUtil.errToObj(message) });\n    }\n    url(message) {\n        return this._addCheck({ kind: \"url\", ...errorUtil.errToObj(message) });\n    }\n    uuid(message) {\n        return this._addCheck({ kind: \"uuid\", ...errorUtil.errToObj(message) });\n    }\n    cuid(message) {\n        return this._addCheck({ kind: \"cuid\", ...errorUtil.errToObj(message) });\n    }\n    datetime(options) {\n        var _a;\n        if (typeof options === \"string\") {\n            return this._addCheck({\n                kind: \"datetime\",\n                precision: null,\n                offset: false,\n                message: options,\n            });\n        }\n        return this._addCheck({\n            kind: \"datetime\",\n            precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === \"undefined\" ? null : options === null || options === void 0 ? void 0 : options.precision,\n            offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,\n            ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message),\n        });\n    }\n    regex(regex, message) {\n        return this._addCheck({\n            kind: \"regex\",\n            regex: regex,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    startsWith(value, message) {\n        return this._addCheck({\n            kind: \"startsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    endsWith(value, message) {\n        return this._addCheck({\n            kind: \"endsWith\",\n            value: value,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    min(minLength, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    max(maxLength, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxLength,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    length(len, message) {\n        return this._addCheck({\n            kind: \"length\",\n            value: len,\n            ...errorUtil.errToObj(message),\n        });\n    }\n    get isDatetime() {\n        return !!this._def.checks.find((ch) => ch.kind === \"datetime\");\n    }\n    get isEmail() {\n        return !!this._def.checks.find((ch) => ch.kind === \"email\");\n    }\n    get isURL() {\n        return !!this._def.checks.find((ch) => ch.kind === \"url\");\n    }\n    get isUUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"uuid\");\n    }\n    get isCUID() {\n        return !!this._def.checks.find((ch) => ch.kind === \"cuid\");\n    }\n    get minLength() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxLength() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n}\nZodString.create = (params) => {\n    var _a;\n    return new ZodString({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodString,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\n// https://stackoverflow.com/questions/3966484/why-does-modulus-operator-return-fractional-number-in-javascript/31711034#31711034\nfunction floatSafeRemainder(val, step) {\n    const valDecCount = (val.toString().split(\".\")[1] || \"\").length;\n    const stepDecCount = (step.toString().split(\".\")[1] || \"\").length;\n    const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;\n    const valInt = parseInt(val.toFixed(decCount).replace(\".\", \"\"));\n    const stepInt = parseInt(step.toFixed(decCount).replace(\".\", \"\"));\n    return (valInt % stepInt) / Math.pow(10, decCount);\n}\nclass ZodNumber extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.min = this.gte;\n        this.max = this.lte;\n        this.step = this.multipleOf;\n    }\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Number(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.number) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.number,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        let ctx = undefined;\n        const status = new ParseStatus();\n        for (const check of this._def.checks) {\n            if (check.kind === \"int\") {\n                if (!util.isInteger(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.invalid_type,\n                        expected: \"integer\",\n                        received: \"float\",\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"min\") {\n                const tooSmall = check.inclusive\n                    ? input.data < check.value\n                    : input.data <= check.value;\n                if (tooSmall) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        minimum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                const tooBig = check.inclusive\n                    ? input.data > check.value\n                    : input.data >= check.value;\n                if (tooBig) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        maximum: check.value,\n                        type: \"number\",\n                        inclusive: check.inclusive,\n                        exact: false,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"multipleOf\") {\n                if (floatSafeRemainder(input.data, check.value) !== 0) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_multiple_of,\n                        multipleOf: check.value,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"finite\") {\n                if (!Number.isFinite(input.data)) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.not_finite,\n                        message: check.message,\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return { status: status.value, value: input.data };\n    }\n    gte(value, message) {\n        return this.setLimit(\"min\", value, true, errorUtil.toString(message));\n    }\n    gt(value, message) {\n        return this.setLimit(\"min\", value, false, errorUtil.toString(message));\n    }\n    lte(value, message) {\n        return this.setLimit(\"max\", value, true, errorUtil.toString(message));\n    }\n    lt(value, message) {\n        return this.setLimit(\"max\", value, false, errorUtil.toString(message));\n    }\n    setLimit(kind, value, inclusive, message) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [\n                ...this._def.checks,\n                {\n                    kind,\n                    value,\n                    inclusive,\n                    message: errorUtil.toString(message),\n                },\n            ],\n        });\n    }\n    _addCheck(check) {\n        return new ZodNumber({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    int(message) {\n        return this._addCheck({\n            kind: \"int\",\n            message: errorUtil.toString(message),\n        });\n    }\n    positive(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    negative(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: false,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonpositive(message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    nonnegative(message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: 0,\n            inclusive: true,\n            message: errorUtil.toString(message),\n        });\n    }\n    multipleOf(value, message) {\n        return this._addCheck({\n            kind: \"multipleOf\",\n            value: value,\n            message: errorUtil.toString(message),\n        });\n    }\n    finite(message) {\n        return this._addCheck({\n            kind: \"finite\",\n            message: errorUtil.toString(message),\n        });\n    }\n    get minValue() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min;\n    }\n    get maxValue() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max;\n    }\n    get isInt() {\n        return !!this._def.checks.find((ch) => ch.kind === \"int\");\n    }\n}\nZodNumber.create = (params) => {\n    return new ZodNumber({\n        checks: [],\n        typeName: ZodFirstPartyTypeKind.ZodNumber,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBigInt extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = BigInt(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.bigint) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.bigint,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBigInt.create = (params) => {\n    var _a;\n    return new ZodBigInt({\n        typeName: ZodFirstPartyTypeKind.ZodBigInt,\n        coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodBoolean extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = Boolean(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.boolean) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.boolean,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodBoolean.create = (params) => {\n    return new ZodBoolean({\n        typeName: ZodFirstPartyTypeKind.ZodBoolean,\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDate extends ZodType {\n    _parse(input) {\n        if (this._def.coerce) {\n            input.data = new Date(input.data);\n        }\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.date) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.date,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (isNaN(input.data.getTime())) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_date,\n            });\n            return INVALID;\n        }\n        const status = new ParseStatus();\n        let ctx = undefined;\n        for (const check of this._def.checks) {\n            if (check.kind === \"min\") {\n                if (input.data.getTime() < check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_small,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        minimum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else if (check.kind === \"max\") {\n                if (input.data.getTime() > check.value) {\n                    ctx = this._getOrReturnCtx(input, ctx);\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.too_big,\n                        message: check.message,\n                        inclusive: true,\n                        exact: false,\n                        maximum: check.value,\n                        type: \"date\",\n                    });\n                    status.dirty();\n                }\n            }\n            else {\n                util.assertNever(check);\n            }\n        }\n        return {\n            status: status.value,\n            value: new Date(input.data.getTime()),\n        };\n    }\n    _addCheck(check) {\n        return new ZodDate({\n            ...this._def,\n            checks: [...this._def.checks, check],\n        });\n    }\n    min(minDate, message) {\n        return this._addCheck({\n            kind: \"min\",\n            value: minDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    max(maxDate, message) {\n        return this._addCheck({\n            kind: \"max\",\n            value: maxDate.getTime(),\n            message: errorUtil.toString(message),\n        });\n    }\n    get minDate() {\n        let min = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"min\") {\n                if (min === null || ch.value > min)\n                    min = ch.value;\n            }\n        }\n        return min != null ? new Date(min) : null;\n    }\n    get maxDate() {\n        let max = null;\n        for (const ch of this._def.checks) {\n            if (ch.kind === \"max\") {\n                if (max === null || ch.value < max)\n                    max = ch.value;\n            }\n        }\n        return max != null ? new Date(max) : null;\n    }\n}\nZodDate.create = (params) => {\n    return new ZodDate({\n        checks: [],\n        coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,\n        typeName: ZodFirstPartyTypeKind.ZodDate,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSymbol extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.symbol) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.symbol,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodSymbol.create = (params) => {\n    return new ZodSymbol({\n        typeName: ZodFirstPartyTypeKind.ZodSymbol,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUndefined extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.undefined,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodUndefined.create = (params) => {\n    return new ZodUndefined({\n        typeName: ZodFirstPartyTypeKind.ZodUndefined,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNull extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.null) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.null,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodNull.create = (params) => {\n    return new ZodNull({\n        typeName: ZodFirstPartyTypeKind.ZodNull,\n        ...processCreateParams(params),\n    });\n};\nclass ZodAny extends ZodType {\n    constructor() {\n        super(...arguments);\n        // to prevent instances of other classes from extending ZodAny. this causes issues with catchall in ZodObject.\n        this._any = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodAny.create = (params) => {\n    return new ZodAny({\n        typeName: ZodFirstPartyTypeKind.ZodAny,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnknown extends ZodType {\n    constructor() {\n        super(...arguments);\n        // required\n        this._unknown = true;\n    }\n    _parse(input) {\n        return OK(input.data);\n    }\n}\nZodUnknown.create = (params) => {\n    return new ZodUnknown({\n        typeName: ZodFirstPartyTypeKind.ZodUnknown,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNever extends ZodType {\n    _parse(input) {\n        const ctx = this._getOrReturnCtx(input);\n        addIssueToContext(ctx, {\n            code: ZodIssueCode.invalid_type,\n            expected: ZodParsedType.never,\n            received: ctx.parsedType,\n        });\n        return INVALID;\n    }\n}\nZodNever.create = (params) => {\n    return new ZodNever({\n        typeName: ZodFirstPartyTypeKind.ZodNever,\n        ...processCreateParams(params),\n    });\n};\nclass ZodVoid extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.undefined) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.void,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n}\nZodVoid.create = (params) => {\n    return new ZodVoid({\n        typeName: ZodFirstPartyTypeKind.ZodVoid,\n        ...processCreateParams(params),\n    });\n};\nclass ZodArray extends ZodType {\n    _parse(input) {\n        const { ctx, status } = this._processInputParams(input);\n        const def = this._def;\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (def.exactLength !== null) {\n            const tooBig = ctx.data.length > def.exactLength.value;\n            const tooSmall = ctx.data.length < def.exactLength.value;\n            if (tooBig || tooSmall) {\n                addIssueToContext(ctx, {\n                    code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,\n                    minimum: (tooSmall ? def.exactLength.value : undefined),\n                    maximum: (tooBig ? def.exactLength.value : undefined),\n                    type: \"array\",\n                    inclusive: true,\n                    exact: true,\n                    message: def.exactLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.minLength !== null) {\n            if (ctx.data.length < def.minLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxLength !== null) {\n            if (ctx.data.length > def.maxLength.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxLength.value,\n                    type: \"array\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxLength.message,\n                });\n                status.dirty();\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.all(ctx.data.map((item, i) => {\n                return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n            })).then((result) => {\n                return ParseStatus.mergeArray(status, result);\n            });\n        }\n        const result = ctx.data.map((item, i) => {\n            return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));\n        });\n        return ParseStatus.mergeArray(status, result);\n    }\n    get element() {\n        return this._def.type;\n    }\n    min(minLength, message) {\n        return new ZodArray({\n            ...this._def,\n            minLength: { value: minLength, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxLength, message) {\n        return new ZodArray({\n            ...this._def,\n            maxLength: { value: maxLength, message: errorUtil.toString(message) },\n        });\n    }\n    length(len, message) {\n        return new ZodArray({\n            ...this._def,\n            exactLength: { value: len, message: errorUtil.toString(message) },\n        });\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodArray.create = (schema, params) => {\n    return new ZodArray({\n        type: schema,\n        minLength: null,\n        maxLength: null,\n        exactLength: null,\n        typeName: ZodFirstPartyTypeKind.ZodArray,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////\n/////////////////////////////////////////\n//////////                     //////////\n//////////      ZodObject      //////////\n//////////                     //////////\n/////////////////////////////////////////\n/////////////////////////////////////////\nvar objectUtil;\n(function (objectUtil) {\n    objectUtil.mergeShapes = (first, second) => {\n        return {\n            ...first,\n            ...second, // second overwrites first\n        };\n    };\n})(objectUtil || (objectUtil = {}));\nconst AugmentFactory = (def) => (augmentation) => {\n    return new ZodObject({\n        ...def,\n        shape: () => ({\n            ...def.shape(),\n            ...augmentation,\n        }),\n    });\n};\nfunction deepPartialify(schema) {\n    if (schema instanceof ZodObject) {\n        const newShape = {};\n        for (const key in schema.shape) {\n            const fieldSchema = schema.shape[key];\n            newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));\n        }\n        return new ZodObject({\n            ...schema._def,\n            shape: () => newShape,\n        });\n    }\n    else if (schema instanceof ZodArray) {\n        return ZodArray.create(deepPartialify(schema.element));\n    }\n    else if (schema instanceof ZodOptional) {\n        return ZodOptional.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodNullable) {\n        return ZodNullable.create(deepPartialify(schema.unwrap()));\n    }\n    else if (schema instanceof ZodTuple) {\n        return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));\n    }\n    else {\n        return schema;\n    }\n}\nclass ZodObject extends ZodType {\n    constructor() {\n        super(...arguments);\n        this._cached = null;\n        /**\n         * @deprecated In most cases, this is no longer needed - unknown properties are now silently stripped.\n         * If you want to pass through unknown properties, use `.passthrough()` instead.\n         */\n        this.nonstrict = this.passthrough;\n        this.augment = AugmentFactory(this._def);\n        this.extend = AugmentFactory(this._def);\n    }\n    _getCached() {\n        if (this._cached !== null)\n            return this._cached;\n        const shape = this._def.shape();\n        const keys = util.objectKeys(shape);\n        return (this._cached = { shape, keys });\n    }\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.object) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const { status, ctx } = this._processInputParams(input);\n        const { shape, keys: shapeKeys } = this._getCached();\n        const extraKeys = [];\n        if (!(this._def.catchall instanceof ZodNever &&\n            this._def.unknownKeys === \"strip\")) {\n            for (const key in ctx.data) {\n                if (!shapeKeys.includes(key)) {\n                    extraKeys.push(key);\n                }\n            }\n        }\n        const pairs = [];\n        for (const key of shapeKeys) {\n            const keyValidator = shape[key];\n            const value = ctx.data[key];\n            pairs.push({\n                key: { status: \"valid\", value: key },\n                value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),\n                alwaysSet: key in ctx.data,\n            });\n        }\n        if (this._def.catchall instanceof ZodNever) {\n            const unknownKeys = this._def.unknownKeys;\n            if (unknownKeys === \"passthrough\") {\n                for (const key of extraKeys) {\n                    pairs.push({\n                        key: { status: \"valid\", value: key },\n                        value: { status: \"valid\", value: ctx.data[key] },\n                    });\n                }\n            }\n            else if (unknownKeys === \"strict\") {\n                if (extraKeys.length > 0) {\n                    addIssueToContext(ctx, {\n                        code: ZodIssueCode.unrecognized_keys,\n                        keys: extraKeys,\n                    });\n                    status.dirty();\n                }\n            }\n            else if (unknownKeys === \"strip\") ;\n            else {\n                throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);\n            }\n        }\n        else {\n            // run catchall validation\n            const catchall = this._def.catchall;\n            for (const key of extraKeys) {\n                const value = ctx.data[key];\n                pairs.push({\n                    key: { status: \"valid\", value: key },\n                    value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key) //, ctx.child(key), value, getParsedType(value)\n                    ),\n                    alwaysSet: key in ctx.data,\n                });\n            }\n        }\n        if (ctx.common.async) {\n            return Promise.resolve()\n                .then(async () => {\n                const syncPairs = [];\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    syncPairs.push({\n                        key,\n                        value: await pair.value,\n                        alwaysSet: pair.alwaysSet,\n                    });\n                }\n                return syncPairs;\n            })\n                .then((syncPairs) => {\n                return ParseStatus.mergeObjectSync(status, syncPairs);\n            });\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get shape() {\n        return this._def.shape();\n    }\n    strict(message) {\n        errorUtil.errToObj;\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strict\",\n            ...(message !== undefined\n                ? {\n                    errorMap: (issue, ctx) => {\n                        var _a, _b, _c, _d;\n                        const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;\n                        if (issue.code === \"unrecognized_keys\")\n                            return {\n                                message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError,\n                            };\n                        return {\n                            message: defaultError,\n                        };\n                    },\n                }\n                : {}),\n        });\n    }\n    strip() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"strip\",\n        });\n    }\n    passthrough() {\n        return new ZodObject({\n            ...this._def,\n            unknownKeys: \"passthrough\",\n        });\n    }\n    setKey(key, schema) {\n        return this.augment({ [key]: schema });\n    }\n    /**\n     * Prior to zod@1.0.12 there was a bug in the\n     * inferred type of merged objects. Please\n     * upgrade if you are experiencing issues.\n     */\n    merge(merging) {\n        // const mergedShape = objectUtil.mergeShapes(\n        //   this._def.shape(),\n        //   merging._def.shape()\n        // );\n        const merged = new ZodObject({\n            unknownKeys: merging._def.unknownKeys,\n            catchall: merging._def.catchall,\n            shape: () => objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),\n            typeName: ZodFirstPartyTypeKind.ZodObject,\n        });\n        return merged;\n    }\n    catchall(index) {\n        return new ZodObject({\n            ...this._def,\n            catchall: index,\n        });\n    }\n    pick(mask) {\n        const shape = {};\n        util.objectKeys(mask).map((key) => {\n            // only add to shape if key corresponds to an element of the current shape\n            if (this.shape[key])\n                shape[key] = this.shape[key];\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    omit(mask) {\n        const shape = {};\n        util.objectKeys(this.shape).map((key) => {\n            if (util.objectKeys(mask).indexOf(key) === -1) {\n                shape[key] = this.shape[key];\n            }\n        });\n        return new ZodObject({\n            ...this._def,\n            shape: () => shape,\n        });\n    }\n    deepPartial() {\n        return deepPartialify(this);\n    }\n    partial(mask) {\n        const newShape = {};\n        if (mask) {\n            util.objectKeys(this.shape).map((key) => {\n                if (util.objectKeys(mask).indexOf(key) === -1) {\n                    newShape[key] = this.shape[key];\n                }\n                else {\n                    newShape[key] = this.shape[key].optional();\n                }\n            });\n            return new ZodObject({\n                ...this._def,\n                shape: () => newShape,\n            });\n        }\n        else {\n            for (const key in this.shape) {\n                const fieldSchema = this.shape[key];\n                newShape[key] = fieldSchema.optional();\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    required(mask) {\n        const newShape = {};\n        if (mask) {\n            util.objectKeys(this.shape).map((key) => {\n                if (util.objectKeys(mask).indexOf(key) === -1) {\n                    newShape[key] = this.shape[key];\n                }\n                else {\n                    const fieldSchema = this.shape[key];\n                    let newField = fieldSchema;\n                    while (newField instanceof ZodOptional) {\n                        newField = newField._def.innerType;\n                    }\n                    newShape[key] = newField;\n                }\n            });\n        }\n        else {\n            for (const key in this.shape) {\n                const fieldSchema = this.shape[key];\n                let newField = fieldSchema;\n                while (newField instanceof ZodOptional) {\n                    newField = newField._def.innerType;\n                }\n                newShape[key] = newField;\n            }\n        }\n        return new ZodObject({\n            ...this._def,\n            shape: () => newShape,\n        });\n    }\n    keyof() {\n        return createZodEnum(util.objectKeys(this.shape));\n    }\n}\nZodObject.create = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.strictCreate = (shape, params) => {\n    return new ZodObject({\n        shape: () => shape,\n        unknownKeys: \"strict\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nZodObject.lazycreate = (shape, params) => {\n    return new ZodObject({\n        shape,\n        unknownKeys: \"strip\",\n        catchall: ZodNever.create(),\n        typeName: ZodFirstPartyTypeKind.ZodObject,\n        ...processCreateParams(params),\n    });\n};\nclass ZodUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const options = this._def.options;\n        function handleResults(results) {\n            // return first issue-free validation if it exists\n            for (const result of results) {\n                if (result.result.status === \"valid\") {\n                    return result.result;\n                }\n            }\n            for (const result of results) {\n                if (result.result.status === \"dirty\") {\n                    // add issues from dirty option\n                    ctx.common.issues.push(...result.ctx.common.issues);\n                    return result.result;\n                }\n            }\n            // return invalid\n            const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return Promise.all(options.map(async (option) => {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                return {\n                    result: await option._parseAsync({\n                        data: ctx.data,\n                        path: ctx.path,\n                        parent: childCtx,\n                    }),\n                    ctx: childCtx,\n                };\n            })).then(handleResults);\n        }\n        else {\n            let dirty = undefined;\n            const issues = [];\n            for (const option of options) {\n                const childCtx = {\n                    ...ctx,\n                    common: {\n                        ...ctx.common,\n                        issues: [],\n                    },\n                    parent: null,\n                };\n                const result = option._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: childCtx,\n                });\n                if (result.status === \"valid\") {\n                    return result;\n                }\n                else if (result.status === \"dirty\" && !dirty) {\n                    dirty = { result, ctx: childCtx };\n                }\n                if (childCtx.common.issues.length) {\n                    issues.push(childCtx.common.issues);\n                }\n            }\n            if (dirty) {\n                ctx.common.issues.push(...dirty.ctx.common.issues);\n                return dirty.result;\n            }\n            const unionErrors = issues.map((issues) => new ZodError(issues));\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union,\n                unionErrors,\n            });\n            return INVALID;\n        }\n    }\n    get options() {\n        return this._def.options;\n    }\n}\nZodUnion.create = (types, params) => {\n    return new ZodUnion({\n        options: types,\n        typeName: ZodFirstPartyTypeKind.ZodUnion,\n        ...processCreateParams(params),\n    });\n};\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\n//////////                                 //////////\n//////////      ZodDiscriminatedUnion      //////////\n//////////                                 //////////\n/////////////////////////////////////////////////////\n/////////////////////////////////////////////////////\nconst getDiscriminator = (type) => {\n    if (type instanceof ZodLazy) {\n        return getDiscriminator(type.schema);\n    }\n    else if (type instanceof ZodEffects) {\n        return getDiscriminator(type.innerType());\n    }\n    else if (type instanceof ZodLiteral) {\n        return [type.value];\n    }\n    else if (type instanceof ZodEnum) {\n        return type.options;\n    }\n    else if (type instanceof ZodNativeEnum) {\n        // eslint-disable-next-line ban/ban\n        return Object.keys(type.enum);\n    }\n    else if (type instanceof ZodDefault) {\n        return getDiscriminator(type._def.innerType);\n    }\n    else if (type instanceof ZodUndefined) {\n        return [undefined];\n    }\n    else if (type instanceof ZodNull) {\n        return [null];\n    }\n    else {\n        return null;\n    }\n};\nclass ZodDiscriminatedUnion extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const discriminator = this.discriminator;\n        const discriminatorValue = ctx.data[discriminator];\n        const option = this.optionsMap.get(discriminatorValue);\n        if (!option) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_union_discriminator,\n                options: Array.from(this.optionsMap.keys()),\n                path: [discriminator],\n            });\n            return INVALID;\n        }\n        if (ctx.common.async) {\n            return option._parseAsync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n        else {\n            return option._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n        }\n    }\n    get discriminator() {\n        return this._def.discriminator;\n    }\n    get options() {\n        return this._def.options;\n    }\n    get optionsMap() {\n        return this._def.optionsMap;\n    }\n    /**\n     * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.\n     * However, it only allows a union of objects, all of which need to share a discriminator property. This property must\n     * have a different value for each object in the union.\n     * @param discriminator the name of the discriminator property\n     * @param types an array of object schemas\n     * @param params\n     */\n    static create(discriminator, options, params) {\n        // Get all the valid discriminator values\n        const optionsMap = new Map();\n        // try {\n        for (const type of options) {\n            const discriminatorValues = getDiscriminator(type.shape[discriminator]);\n            if (!discriminatorValues) {\n                throw new Error(`A discriminator value for key \\`${discriminator}\\` could not be extracted from all schema options`);\n            }\n            for (const value of discriminatorValues) {\n                if (optionsMap.has(value)) {\n                    throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);\n                }\n                optionsMap.set(value, type);\n            }\n        }\n        return new ZodDiscriminatedUnion({\n            typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,\n            discriminator,\n            options,\n            optionsMap,\n            ...processCreateParams(params),\n        });\n    }\n}\nfunction mergeValues(a, b) {\n    const aType = getParsedType(a);\n    const bType = getParsedType(b);\n    if (a === b) {\n        return { valid: true, data: a };\n    }\n    else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {\n        const bKeys = util.objectKeys(b);\n        const sharedKeys = util\n            .objectKeys(a)\n            .filter((key) => bKeys.indexOf(key) !== -1);\n        const newObj = { ...a, ...b };\n        for (const key of sharedKeys) {\n            const sharedValue = mergeValues(a[key], b[key]);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newObj[key] = sharedValue.data;\n        }\n        return { valid: true, data: newObj };\n    }\n    else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {\n        if (a.length !== b.length) {\n            return { valid: false };\n        }\n        const newArray = [];\n        for (let index = 0; index < a.length; index++) {\n            const itemA = a[index];\n            const itemB = b[index];\n            const sharedValue = mergeValues(itemA, itemB);\n            if (!sharedValue.valid) {\n                return { valid: false };\n            }\n            newArray.push(sharedValue.data);\n        }\n        return { valid: true, data: newArray };\n    }\n    else if (aType === ZodParsedType.date &&\n        bType === ZodParsedType.date &&\n        +a === +b) {\n        return { valid: true, data: a };\n    }\n    else {\n        return { valid: false };\n    }\n}\nclass ZodIntersection extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const handleParsed = (parsedLeft, parsedRight) => {\n            if (isAborted(parsedLeft) || isAborted(parsedRight)) {\n                return INVALID;\n            }\n            const merged = mergeValues(parsedLeft.value, parsedRight.value);\n            if (!merged.valid) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.invalid_intersection_types,\n                });\n                return INVALID;\n            }\n            if (isDirty(parsedLeft) || isDirty(parsedRight)) {\n                status.dirty();\n            }\n            return { status: status.value, value: merged.data };\n        };\n        if (ctx.common.async) {\n            return Promise.all([\n                this._def.left._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n                this._def.right._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                }),\n            ]).then(([left, right]) => handleParsed(left, right));\n        }\n        else {\n            return handleParsed(this._def.left._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }), this._def.right._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            }));\n        }\n    }\n}\nZodIntersection.create = (left, right, params) => {\n    return new ZodIntersection({\n        left: left,\n        right: right,\n        typeName: ZodFirstPartyTypeKind.ZodIntersection,\n        ...processCreateParams(params),\n    });\n};\nclass ZodTuple extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.array) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.array,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        if (ctx.data.length < this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_small,\n                minimum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            return INVALID;\n        }\n        const rest = this._def.rest;\n        if (!rest && ctx.data.length > this._def.items.length) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.too_big,\n                maximum: this._def.items.length,\n                inclusive: true,\n                exact: false,\n                type: \"array\",\n            });\n            status.dirty();\n        }\n        const items = ctx.data\n            .map((item, itemIndex) => {\n            const schema = this._def.items[itemIndex] || this._def.rest;\n            if (!schema)\n                return null;\n            return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));\n        })\n            .filter((x) => !!x); // filter nulls\n        if (ctx.common.async) {\n            return Promise.all(items).then((results) => {\n                return ParseStatus.mergeArray(status, results);\n            });\n        }\n        else {\n            return ParseStatus.mergeArray(status, items);\n        }\n    }\n    get items() {\n        return this._def.items;\n    }\n    rest(rest) {\n        return new ZodTuple({\n            ...this._def,\n            rest,\n        });\n    }\n}\nZodTuple.create = (schemas, params) => {\n    if (!Array.isArray(schemas)) {\n        throw new Error(\"You must pass an array of schemas to z.tuple([ ... ])\");\n    }\n    return new ZodTuple({\n        items: schemas,\n        typeName: ZodFirstPartyTypeKind.ZodTuple,\n        rest: null,\n        ...processCreateParams(params),\n    });\n};\nclass ZodRecord extends ZodType {\n    get keySchema() {\n        return this._def.keyType;\n    }\n    get valueSchema() {\n        return this._def.valueType;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.object) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.object,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const pairs = [];\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        for (const key in ctx.data) {\n            pairs.push({\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),\n                value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),\n            });\n        }\n        if (ctx.common.async) {\n            return ParseStatus.mergeObjectAsync(status, pairs);\n        }\n        else {\n            return ParseStatus.mergeObjectSync(status, pairs);\n        }\n    }\n    get element() {\n        return this._def.valueType;\n    }\n    static create(first, second, third) {\n        if (second instanceof ZodType) {\n            return new ZodRecord({\n                keyType: first,\n                valueType: second,\n                typeName: ZodFirstPartyTypeKind.ZodRecord,\n                ...processCreateParams(third),\n            });\n        }\n        return new ZodRecord({\n            keyType: ZodString.create(),\n            valueType: first,\n            typeName: ZodFirstPartyTypeKind.ZodRecord,\n            ...processCreateParams(second),\n        });\n    }\n}\nclass ZodMap extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.map) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.map,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const keyType = this._def.keyType;\n        const valueType = this._def.valueType;\n        const pairs = [...ctx.data.entries()].map(([key, value], index) => {\n            return {\n                key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, \"key\"])),\n                value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, \"value\"])),\n            };\n        });\n        if (ctx.common.async) {\n            const finalMap = new Map();\n            return Promise.resolve().then(async () => {\n                for (const pair of pairs) {\n                    const key = await pair.key;\n                    const value = await pair.value;\n                    if (key.status === \"aborted\" || value.status === \"aborted\") {\n                        return INVALID;\n                    }\n                    if (key.status === \"dirty\" || value.status === \"dirty\") {\n                        status.dirty();\n                    }\n                    finalMap.set(key.value, value.value);\n                }\n                return { status: status.value, value: finalMap };\n            });\n        }\n        else {\n            const finalMap = new Map();\n            for (const pair of pairs) {\n                const key = pair.key;\n                const value = pair.value;\n                if (key.status === \"aborted\" || value.status === \"aborted\") {\n                    return INVALID;\n                }\n                if (key.status === \"dirty\" || value.status === \"dirty\") {\n                    status.dirty();\n                }\n                finalMap.set(key.value, value.value);\n            }\n            return { status: status.value, value: finalMap };\n        }\n    }\n}\nZodMap.create = (keyType, valueType, params) => {\n    return new ZodMap({\n        valueType,\n        keyType,\n        typeName: ZodFirstPartyTypeKind.ZodMap,\n        ...processCreateParams(params),\n    });\n};\nclass ZodSet extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.set) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.set,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const def = this._def;\n        if (def.minSize !== null) {\n            if (ctx.data.size < def.minSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_small,\n                    minimum: def.minSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.minSize.message,\n                });\n                status.dirty();\n            }\n        }\n        if (def.maxSize !== null) {\n            if (ctx.data.size > def.maxSize.value) {\n                addIssueToContext(ctx, {\n                    code: ZodIssueCode.too_big,\n                    maximum: def.maxSize.value,\n                    type: \"set\",\n                    inclusive: true,\n                    exact: false,\n                    message: def.maxSize.message,\n                });\n                status.dirty();\n            }\n        }\n        const valueType = this._def.valueType;\n        function finalizeSet(elements) {\n            const parsedSet = new Set();\n            for (const element of elements) {\n                if (element.status === \"aborted\")\n                    return INVALID;\n                if (element.status === \"dirty\")\n                    status.dirty();\n                parsedSet.add(element.value);\n            }\n            return { status: status.value, value: parsedSet };\n        }\n        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));\n        if (ctx.common.async) {\n            return Promise.all(elements).then((elements) => finalizeSet(elements));\n        }\n        else {\n            return finalizeSet(elements);\n        }\n    }\n    min(minSize, message) {\n        return new ZodSet({\n            ...this._def,\n            minSize: { value: minSize, message: errorUtil.toString(message) },\n        });\n    }\n    max(maxSize, message) {\n        return new ZodSet({\n            ...this._def,\n            maxSize: { value: maxSize, message: errorUtil.toString(message) },\n        });\n    }\n    size(size, message) {\n        return this.min(size, message).max(size, message);\n    }\n    nonempty(message) {\n        return this.min(1, message);\n    }\n}\nZodSet.create = (valueType, params) => {\n    return new ZodSet({\n        valueType,\n        minSize: null,\n        maxSize: null,\n        typeName: ZodFirstPartyTypeKind.ZodSet,\n        ...processCreateParams(params),\n    });\n};\nclass ZodFunction extends ZodType {\n    constructor() {\n        super(...arguments);\n        this.validate = this.implement;\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.function) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.function,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        function makeArgsIssue(args, error) {\n            return makeIssue({\n                data: args,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_arguments,\n                    argumentsError: error,\n                },\n            });\n        }\n        function makeReturnsIssue(returns, error) {\n            return makeIssue({\n                data: returns,\n                path: ctx.path,\n                errorMaps: [\n                    ctx.common.contextualErrorMap,\n                    ctx.schemaErrorMap,\n                    getErrorMap(),\n                    errorMap,\n                ].filter((x) => !!x),\n                issueData: {\n                    code: ZodIssueCode.invalid_return_type,\n                    returnTypeError: error,\n                },\n            });\n        }\n        const params = { errorMap: ctx.common.contextualErrorMap };\n        const fn = ctx.data;\n        if (this._def.returns instanceof ZodPromise) {\n            return OK(async (...args) => {\n                const error = new ZodError([]);\n                const parsedArgs = await this._def.args\n                    .parseAsync(args, params)\n                    .catch((e) => {\n                    error.addIssue(makeArgsIssue(args, e));\n                    throw error;\n                });\n                const result = await fn(...parsedArgs);\n                const parsedReturns = await this._def.returns._def.type\n                    .parseAsync(result, params)\n                    .catch((e) => {\n                    error.addIssue(makeReturnsIssue(result, e));\n                    throw error;\n                });\n                return parsedReturns;\n            });\n        }\n        else {\n            return OK((...args) => {\n                const parsedArgs = this._def.args.safeParse(args, params);\n                if (!parsedArgs.success) {\n                    throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);\n                }\n                const result = fn(...parsedArgs.data);\n                const parsedReturns = this._def.returns.safeParse(result, params);\n                if (!parsedReturns.success) {\n                    throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);\n                }\n                return parsedReturns.data;\n            });\n        }\n    }\n    parameters() {\n        return this._def.args;\n    }\n    returnType() {\n        return this._def.returns;\n    }\n    args(...items) {\n        return new ZodFunction({\n            ...this._def,\n            args: ZodTuple.create(items).rest(ZodUnknown.create()),\n        });\n    }\n    returns(returnType) {\n        return new ZodFunction({\n            ...this._def,\n            returns: returnType,\n        });\n    }\n    implement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    strictImplement(func) {\n        const validatedFunc = this.parse(func);\n        return validatedFunc;\n    }\n    static create(args, returns, params) {\n        return new ZodFunction({\n            args: (args\n                ? args\n                : ZodTuple.create([]).rest(ZodUnknown.create())),\n            returns: returns || ZodUnknown.create(),\n            typeName: ZodFirstPartyTypeKind.ZodFunction,\n            ...processCreateParams(params),\n        });\n    }\n}\nclass ZodLazy extends ZodType {\n    get schema() {\n        return this._def.getter();\n    }\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const lazySchema = this._def.getter();\n        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });\n    }\n}\nZodLazy.create = (getter, params) => {\n    return new ZodLazy({\n        getter: getter,\n        typeName: ZodFirstPartyTypeKind.ZodLazy,\n        ...processCreateParams(params),\n    });\n};\nclass ZodLiteral extends ZodType {\n    _parse(input) {\n        if (input.data !== this._def.value) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_literal,\n                expected: this._def.value,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n    get value() {\n        return this._def.value;\n    }\n}\nZodLiteral.create = (value, params) => {\n    return new ZodLiteral({\n        value: value,\n        typeName: ZodFirstPartyTypeKind.ZodLiteral,\n        ...processCreateParams(params),\n    });\n};\nfunction createZodEnum(values, params) {\n    return new ZodEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodEnum,\n        ...processCreateParams(params),\n    });\n}\nclass ZodEnum extends ZodType {\n    _parse(input) {\n        if (typeof input.data !== \"string\") {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (this._def.values.indexOf(input.data) === -1) {\n            const ctx = this._getOrReturnCtx(input);\n            const expectedValues = this._def.values;\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get options() {\n        return this._def.values;\n    }\n    get enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Values() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n    get Enum() {\n        const enumValues = {};\n        for (const val of this._def.values) {\n            enumValues[val] = val;\n        }\n        return enumValues;\n    }\n}\nZodEnum.create = createZodEnum;\nclass ZodNativeEnum extends ZodType {\n    _parse(input) {\n        const nativeEnumValues = util.getValidEnumValues(this._def.values);\n        const ctx = this._getOrReturnCtx(input);\n        if (ctx.parsedType !== ZodParsedType.string &&\n            ctx.parsedType !== ZodParsedType.number) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                expected: util.joinValues(expectedValues),\n                received: ctx.parsedType,\n                code: ZodIssueCode.invalid_type,\n            });\n            return INVALID;\n        }\n        if (nativeEnumValues.indexOf(input.data) === -1) {\n            const expectedValues = util.objectValues(nativeEnumValues);\n            addIssueToContext(ctx, {\n                received: ctx.data,\n                code: ZodIssueCode.invalid_enum_value,\n                options: expectedValues,\n            });\n            return INVALID;\n        }\n        return OK(input.data);\n    }\n    get enum() {\n        return this._def.values;\n    }\n}\nZodNativeEnum.create = (values, params) => {\n    return new ZodNativeEnum({\n        values: values,\n        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,\n        ...processCreateParams(params),\n    });\n};\nclass ZodPromise extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        if (ctx.parsedType !== ZodParsedType.promise &&\n            ctx.common.async === false) {\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.promise,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        const promisified = ctx.parsedType === ZodParsedType.promise\n            ? ctx.data\n            : Promise.resolve(ctx.data);\n        return OK(promisified.then((data) => {\n            return this._def.type.parseAsync(data, {\n                path: ctx.path,\n                errorMap: ctx.common.contextualErrorMap,\n            });\n        }));\n    }\n}\nZodPromise.create = (schema, params) => {\n    return new ZodPromise({\n        type: schema,\n        typeName: ZodFirstPartyTypeKind.ZodPromise,\n        ...processCreateParams(params),\n    });\n};\nclass ZodEffects extends ZodType {\n    innerType() {\n        return this._def.schema;\n    }\n    sourceType() {\n        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects\n            ? this._def.schema.sourceType()\n            : this._def.schema;\n    }\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        const effect = this._def.effect || null;\n        if (effect.type === \"preprocess\") {\n            const processed = effect.transform(ctx.data);\n            if (ctx.common.async) {\n                return Promise.resolve(processed).then((processed) => {\n                    return this._def.schema._parseAsync({\n                        data: processed,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                });\n            }\n            else {\n                return this._def.schema._parseSync({\n                    data: processed,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n        const checkCtx = {\n            addIssue: (arg) => {\n                addIssueToContext(ctx, arg);\n                if (arg.fatal) {\n                    status.abort();\n                }\n                else {\n                    status.dirty();\n                }\n            },\n            get path() {\n                return ctx.path;\n            },\n        };\n        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);\n        if (effect.type === \"refinement\") {\n            const executeRefinement = (acc\n            // effect: RefinementEffect<any>\n            ) => {\n                const result = effect.refinement(acc, checkCtx);\n                if (ctx.common.async) {\n                    return Promise.resolve(result);\n                }\n                if (result instanceof Promise) {\n                    throw new Error(\"Async refinement encountered during synchronous parse operation. Use .parseAsync instead.\");\n                }\n                return acc;\n            };\n            if (ctx.common.async === false) {\n                const inner = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inner.status === \"aborted\")\n                    return INVALID;\n                if (inner.status === \"dirty\")\n                    status.dirty();\n                // return value is ignored\n                executeRefinement(inner.value);\n                return { status: status.value, value: inner.value };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((inner) => {\n                    if (inner.status === \"aborted\")\n                        return INVALID;\n                    if (inner.status === \"dirty\")\n                        status.dirty();\n                    return executeRefinement(inner.value).then(() => {\n                        return { status: status.value, value: inner.value };\n                    });\n                });\n            }\n        }\n        if (effect.type === \"transform\") {\n            if (ctx.common.async === false) {\n                const base = this._def.schema._parseSync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                // if (base.status === \"aborted\") return INVALID;\n                // if (base.status === \"dirty\") {\n                //   return { status: \"dirty\", value: base.value };\n                // }\n                if (!isValid(base))\n                    return base;\n                const result = effect.transform(base.value, checkCtx);\n                if (result instanceof Promise) {\n                    throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);\n                }\n                return { status: status.value, value: result };\n            }\n            else {\n                return this._def.schema\n                    ._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx })\n                    .then((base) => {\n                    if (!isValid(base))\n                        return base;\n                    // if (base.status === \"aborted\") return INVALID;\n                    // if (base.status === \"dirty\") {\n                    //   return { status: \"dirty\", value: base.value };\n                    // }\n                    return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));\n                });\n            }\n        }\n        util.assertNever(effect);\n    }\n}\nZodEffects.create = (schema, effect, params) => {\n    return new ZodEffects({\n        schema,\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        effect,\n        ...processCreateParams(params),\n    });\n};\nZodEffects.createWithPreprocess = (preprocess, schema, params) => {\n    return new ZodEffects({\n        schema,\n        effect: { type: \"preprocess\", transform: preprocess },\n        typeName: ZodFirstPartyTypeKind.ZodEffects,\n        ...processCreateParams(params),\n    });\n};\nclass ZodOptional extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.undefined) {\n            return OK(undefined);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodOptional.create = (type, params) => {\n    return new ZodOptional({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodOptional,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNullable extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType === ZodParsedType.null) {\n            return OK(null);\n        }\n        return this._def.innerType._parse(input);\n    }\n    unwrap() {\n        return this._def.innerType;\n    }\n}\nZodNullable.create = (type, params) => {\n    return new ZodNullable({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodNullable,\n        ...processCreateParams(params),\n    });\n};\nclass ZodDefault extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        let data = ctx.data;\n        if (ctx.parsedType === ZodParsedType.undefined) {\n            data = this._def.defaultValue();\n        }\n        return this._def.innerType._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodDefault.create = (type, params) => {\n    return new ZodDefault({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodDefault,\n        defaultValue: typeof params.default === \"function\"\n            ? params.default\n            : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nclass ZodCatch extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const result = this._def.innerType._parse({\n            data: ctx.data,\n            path: ctx.path,\n            parent: ctx,\n        });\n        if (isAsync(result)) {\n            return result.then((result) => {\n                return {\n                    status: \"valid\",\n                    value: result.status === \"valid\" ? result.value : this._def.defaultValue(),\n                };\n            });\n        }\n        else {\n            return {\n                status: \"valid\",\n                value: result.status === \"valid\" ? result.value : this._def.defaultValue(),\n            };\n        }\n    }\n    removeDefault() {\n        return this._def.innerType;\n    }\n}\nZodCatch.create = (type, params) => {\n    return new ZodCatch({\n        innerType: type,\n        typeName: ZodFirstPartyTypeKind.ZodCatch,\n        defaultValue: typeof params.default === \"function\"\n            ? params.default\n            : () => params.default,\n        ...processCreateParams(params),\n    });\n};\nclass ZodNaN extends ZodType {\n    _parse(input) {\n        const parsedType = this._getType(input);\n        if (parsedType !== ZodParsedType.nan) {\n            const ctx = this._getOrReturnCtx(input);\n            addIssueToContext(ctx, {\n                code: ZodIssueCode.invalid_type,\n                expected: ZodParsedType.nan,\n                received: ctx.parsedType,\n            });\n            return INVALID;\n        }\n        return { status: \"valid\", value: input.data };\n    }\n}\nZodNaN.create = (params) => {\n    return new ZodNaN({\n        typeName: ZodFirstPartyTypeKind.ZodNaN,\n        ...processCreateParams(params),\n    });\n};\nconst BRAND = Symbol(\"zod_brand\");\nclass ZodBranded extends ZodType {\n    _parse(input) {\n        const { ctx } = this._processInputParams(input);\n        const data = ctx.data;\n        return this._def.type._parse({\n            data,\n            path: ctx.path,\n            parent: ctx,\n        });\n    }\n    unwrap() {\n        return this._def.type;\n    }\n}\nclass ZodPipeline extends ZodType {\n    _parse(input) {\n        const { status, ctx } = this._processInputParams(input);\n        if (ctx.common.async) {\n            const handleAsync = async () => {\n                const inResult = await this._def.in._parseAsync({\n                    data: ctx.data,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n                if (inResult.status === \"aborted\")\n                    return INVALID;\n                if (inResult.status === \"dirty\") {\n                    status.dirty();\n                    return DIRTY(inResult.value);\n                }\n                else {\n                    return this._def.out._parseAsync({\n                        data: inResult.value,\n                        path: ctx.path,\n                        parent: ctx,\n                    });\n                }\n            };\n            return handleAsync();\n        }\n        else {\n            const inResult = this._def.in._parseSync({\n                data: ctx.data,\n                path: ctx.path,\n                parent: ctx,\n            });\n            if (inResult.status === \"aborted\")\n                return INVALID;\n            if (inResult.status === \"dirty\") {\n                status.dirty();\n                return {\n                    status: \"dirty\",\n                    value: inResult.value,\n                };\n            }\n            else {\n                return this._def.out._parseSync({\n                    data: inResult.value,\n                    path: ctx.path,\n                    parent: ctx,\n                });\n            }\n        }\n    }\n    static create(a, b) {\n        return new ZodPipeline({\n            in: a,\n            out: b,\n            typeName: ZodFirstPartyTypeKind.ZodPipeline,\n        });\n    }\n}\nconst custom = (check, params = {}, fatal) => {\n    if (check)\n        return ZodAny.create().superRefine((data, ctx) => {\n            if (!check(data)) {\n                const p = typeof params === \"function\" ? params(data) : params;\n                const p2 = typeof p === \"string\" ? { message: p } : p;\n                ctx.addIssue({ code: \"custom\", ...p2, fatal });\n            }\n        });\n    return ZodAny.create();\n};\nconst late = {\n    object: ZodObject.lazycreate,\n};\nvar ZodFirstPartyTypeKind;\n(function (ZodFirstPartyTypeKind) {\n    ZodFirstPartyTypeKind[\"ZodString\"] = \"ZodString\";\n    ZodFirstPartyTypeKind[\"ZodNumber\"] = \"ZodNumber\";\n    ZodFirstPartyTypeKind[\"ZodNaN\"] = \"ZodNaN\";\n    ZodFirstPartyTypeKind[\"ZodBigInt\"] = \"ZodBigInt\";\n    ZodFirstPartyTypeKind[\"ZodBoolean\"] = \"ZodBoolean\";\n    ZodFirstPartyTypeKind[\"ZodDate\"] = \"ZodDate\";\n    ZodFirstPartyTypeKind[\"ZodSymbol\"] = \"ZodSymbol\";\n    ZodFirstPartyTypeKind[\"ZodUndefined\"] = \"ZodUndefined\";\n    ZodFirstPartyTypeKind[\"ZodNull\"] = \"ZodNull\";\n    ZodFirstPartyTypeKind[\"ZodAny\"] = \"ZodAny\";\n    ZodFirstPartyTypeKind[\"ZodUnknown\"] = \"ZodUnknown\";\n    ZodFirstPartyTypeKind[\"ZodNever\"] = \"ZodNever\";\n    ZodFirstPartyTypeKind[\"ZodVoid\"] = \"ZodVoid\";\n    ZodFirstPartyTypeKind[\"ZodArray\"] = \"ZodArray\";\n    ZodFirstPartyTypeKind[\"ZodObject\"] = \"ZodObject\";\n    ZodFirstPartyTypeKind[\"ZodUnion\"] = \"ZodUnion\";\n    ZodFirstPartyTypeKind[\"ZodDiscriminatedUnion\"] = \"ZodDiscriminatedUnion\";\n    ZodFirstPartyTypeKind[\"ZodIntersection\"] = \"ZodIntersection\";\n    ZodFirstPartyTypeKind[\"ZodTuple\"] = \"ZodTuple\";\n    ZodFirstPartyTypeKind[\"ZodRecord\"] = \"ZodRecord\";\n    ZodFirstPartyTypeKind[\"ZodMap\"] = \"ZodMap\";\n    ZodFirstPartyTypeKind[\"ZodSet\"] = \"ZodSet\";\n    ZodFirstPartyTypeKind[\"ZodFunction\"] = \"ZodFunction\";\n    ZodFirstPartyTypeKind[\"ZodLazy\"] = \"ZodLazy\";\n    ZodFirstPartyTypeKind[\"ZodLiteral\"] = \"ZodLiteral\";\n    ZodFirstPartyTypeKind[\"ZodEnum\"] = \"ZodEnum\";\n    ZodFirstPartyTypeKind[\"ZodEffects\"] = \"ZodEffects\";\n    ZodFirstPartyTypeKind[\"ZodNativeEnum\"] = \"ZodNativeEnum\";\n    ZodFirstPartyTypeKind[\"ZodOptional\"] = \"ZodOptional\";\n    ZodFirstPartyTypeKind[\"ZodNullable\"] = \"ZodNullable\";\n    ZodFirstPartyTypeKind[\"ZodDefault\"] = \"ZodDefault\";\n    ZodFirstPartyTypeKind[\"ZodCatch\"] = \"ZodCatch\";\n    ZodFirstPartyTypeKind[\"ZodPromise\"] = \"ZodPromise\";\n    ZodFirstPartyTypeKind[\"ZodBranded\"] = \"ZodBranded\";\n    ZodFirstPartyTypeKind[\"ZodPipeline\"] = \"ZodPipeline\";\n})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));\nconst instanceOfType = (\n// const instanceOfType = <T extends new (...args: any[]) => any>(\ncls, params = {\n    message: `Input not instance of ${cls.name}`,\n}) => custom((data) => data instanceof cls, params, true);\nconst stringType = ZodString.create;\nconst numberType = ZodNumber.create;\nconst nanType = ZodNaN.create;\nconst bigIntType = ZodBigInt.create;\nconst booleanType = ZodBoolean.create;\nconst dateType = ZodDate.create;\nconst symbolType = ZodSymbol.create;\nconst undefinedType = ZodUndefined.create;\nconst nullType = ZodNull.create;\nconst anyType = ZodAny.create;\nconst unknownType = ZodUnknown.create;\nconst neverType = ZodNever.create;\nconst voidType = ZodVoid.create;\nconst arrayType = ZodArray.create;\nconst objectType = ZodObject.create;\nconst strictObjectType = ZodObject.strictCreate;\nconst unionType = ZodUnion.create;\nconst discriminatedUnionType = ZodDiscriminatedUnion.create;\nconst intersectionType = ZodIntersection.create;\nconst tupleType = ZodTuple.create;\nconst recordType = ZodRecord.create;\nconst mapType = ZodMap.create;\nconst setType = ZodSet.create;\nconst functionType = ZodFunction.create;\nconst lazyType = ZodLazy.create;\nconst literalType = ZodLiteral.create;\nconst enumType = ZodEnum.create;\nconst nativeEnumType = ZodNativeEnum.create;\nconst promiseType = ZodPromise.create;\nconst effectsType = ZodEffects.create;\nconst optionalType = ZodOptional.create;\nconst nullableType = ZodNullable.create;\nconst preprocessType = ZodEffects.createWithPreprocess;\nconst pipelineType = ZodPipeline.create;\nconst ostring = () => stringType().optional();\nconst onumber = () => numberType().optional();\nconst oboolean = () => booleanType().optional();\nconst coerce = {\n    string: ((arg) => ZodString.create({ ...arg, coerce: true })),\n    number: ((arg) => ZodNumber.create({ ...arg, coerce: true })),\n    boolean: ((arg) => ZodBoolean.create({ ...arg, coerce: true })),\n    bigint: ((arg) => ZodBigInt.create({ ...arg, coerce: true })),\n    date: ((arg) => ZodDate.create({ ...arg, coerce: true })),\n};\nconst NEVER = INVALID;\n\nvar mod = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    defaultErrorMap: errorMap,\n    setErrorMap: setErrorMap,\n    getErrorMap: getErrorMap,\n    makeIssue: makeIssue,\n    EMPTY_PATH: EMPTY_PATH,\n    addIssueToContext: addIssueToContext,\n    ParseStatus: ParseStatus,\n    INVALID: INVALID,\n    DIRTY: DIRTY,\n    OK: OK,\n    isAborted: isAborted,\n    isDirty: isDirty,\n    isValid: isValid,\n    isAsync: isAsync,\n    get util () { return util; },\n    ZodParsedType: ZodParsedType,\n    getParsedType: getParsedType,\n    ZodType: ZodType,\n    ZodString: ZodString,\n    ZodNumber: ZodNumber,\n    ZodBigInt: ZodBigInt,\n    ZodBoolean: ZodBoolean,\n    ZodDate: ZodDate,\n    ZodSymbol: ZodSymbol,\n    ZodUndefined: ZodUndefined,\n    ZodNull: ZodNull,\n    ZodAny: ZodAny,\n    ZodUnknown: ZodUnknown,\n    ZodNever: ZodNever,\n    ZodVoid: ZodVoid,\n    ZodArray: ZodArray,\n    get objectUtil () { return objectUtil; },\n    ZodObject: ZodObject,\n    ZodUnion: ZodUnion,\n    ZodDiscriminatedUnion: ZodDiscriminatedUnion,\n    ZodIntersection: ZodIntersection,\n    ZodTuple: ZodTuple,\n    ZodRecord: ZodRecord,\n    ZodMap: ZodMap,\n    ZodSet: ZodSet,\n    ZodFunction: ZodFunction,\n    ZodLazy: ZodLazy,\n    ZodLiteral: ZodLiteral,\n    ZodEnum: ZodEnum,\n    ZodNativeEnum: ZodNativeEnum,\n    ZodPromise: ZodPromise,\n    ZodEffects: ZodEffects,\n    ZodTransformer: ZodEffects,\n    ZodOptional: ZodOptional,\n    ZodNullable: ZodNullable,\n    ZodDefault: ZodDefault,\n    ZodCatch: ZodCatch,\n    ZodNaN: ZodNaN,\n    BRAND: BRAND,\n    ZodBranded: ZodBranded,\n    ZodPipeline: ZodPipeline,\n    custom: custom,\n    Schema: ZodType,\n    ZodSchema: ZodType,\n    late: late,\n    get ZodFirstPartyTypeKind () { return ZodFirstPartyTypeKind; },\n    coerce: coerce,\n    any: anyType,\n    array: arrayType,\n    bigint: bigIntType,\n    boolean: booleanType,\n    date: dateType,\n    discriminatedUnion: discriminatedUnionType,\n    effect: effectsType,\n    'enum': enumType,\n    'function': functionType,\n    'instanceof': instanceOfType,\n    intersection: intersectionType,\n    lazy: lazyType,\n    literal: literalType,\n    map: mapType,\n    nan: nanType,\n    nativeEnum: nativeEnumType,\n    never: neverType,\n    'null': nullType,\n    nullable: nullableType,\n    number: numberType,\n    object: objectType,\n    oboolean: oboolean,\n    onumber: onumber,\n    optional: optionalType,\n    ostring: ostring,\n    pipeline: pipelineType,\n    preprocess: preprocessType,\n    promise: promiseType,\n    record: recordType,\n    set: setType,\n    strictObject: strictObjectType,\n    string: stringType,\n    symbol: symbolType,\n    transformer: effectsType,\n    tuple: tupleType,\n    'undefined': undefinedType,\n    union: unionType,\n    unknown: unknownType,\n    'void': voidType,\n    NEVER: NEVER,\n    ZodIssueCode: ZodIssueCode,\n    quotelessJson: quotelessJson,\n    ZodError: ZodError\n});\n\nexport { BRAND, DIRTY, EMPTY_PATH, INVALID, NEVER, OK, ParseStatus, ZodType as Schema, ZodAny, ZodArray, ZodBigInt, ZodBoolean, ZodBranded, ZodCatch, ZodDate, ZodDefault, ZodDiscriminatedUnion, ZodEffects, ZodEnum, ZodError, ZodFirstPartyTypeKind, ZodFunction, ZodIntersection, ZodIssueCode, ZodLazy, ZodLiteral, ZodMap, ZodNaN, ZodNativeEnum, ZodNever, ZodNull, ZodNullable, ZodNumber, ZodObject, ZodOptional, ZodParsedType, ZodPipeline, ZodPromise, ZodRecord, ZodType as ZodSchema, ZodSet, ZodString, ZodSymbol, ZodEffects as ZodTransformer, ZodTuple, ZodType, ZodUndefined, ZodUnion, ZodUnknown, ZodVoid, addIssueToContext, anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, coerce, custom, dateType as date, mod as default, errorMap as defaultErrorMap, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, getErrorMap, getParsedType, instanceOfType as instanceof, intersectionType as intersection, isAborted, isAsync, isDirty, isValid, late, lazyType as lazy, literalType as literal, makeIssue, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, objectUtil, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, quotelessJson, recordType as record, setType as set, setErrorMap, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, util, voidType as void, mod as z };\n","import { printTypeSig } from \"../../stdlib/stdlib\";\nimport { indent, wrongTypeError } from \"./type-errors\";\nexport function isCompatible(src, dst) {\n    for (const type of dst) {\n        if (src.type == \"list\" && type.type == \"list\") {\n            if (src.element.type == type.element.type) {\n                return true;\n            }\n            continue;\n        }\n        if (src.type == type.type)\n            return true;\n    }\n    return false;\n}\nexport function typecheckBuiltinFn(call, paramTypes, def, ctx) {\n    outer: for (const overload of def.typeSignature) {\n        if (overload.type == \"variadic\") {\n            if (paramTypes.length >= (overload.minArgs ?? 0) &&\n                paramTypes.every((e) => isCompatible(e, overload.validTypes))) {\n                return overload.returns;\n            }\n        }\n        else {\n            if (paramTypes.length > overload.params.length ||\n                paramTypes.length < (overload.requiredCount ?? overload.params.length))\n                continue;\n            for (let i = 0; i < paramTypes.length; i++) {\n                if (!isCompatible(paramTypes[i], overload.params[i]))\n                    continue outer;\n            }\n            return overload.returns;\n        }\n    }\n    return wrongTypeError(call, ctx.unitName, \"invalid function parameters; valid overloads are:\\n\" +\n        indent(printTypeSig(def.typeSignature), 2));\n}\n","import { getErrors, } from \"../../ast/ast\";\nimport { asExpr, } from \"../../ast/ast\";\nimport { formatAST } from \"../../ast/fmt\";\nimport { assertNotUndefined, internalError } from \"../../compiler-errors\";\nimport { findIdentifierScopeItem } from \"../create-scope-tree\";\nimport { formatCircularDependencyError, notFoundError, wrongTypeError, formatScopeItemTypeName, badMacroError, } from \"./type-errors\";\nimport { consolidateTypeErrors } from \"./typecheck-binop\";\nimport { typecheckBinop } from \"./typecheck-binop\";\nimport { typecheckBuiltinFn } from \"./typecheck-builtin-fn\";\nexport function typeAsStr(type) {\n    if (type.type == \"list\")\n        return `${typeAsStr(type.element)}[]`;\n    return type.type;\n}\nexport function getASTNode(ctx, id, requiredType) {\n    const node = ctx.astNodes.get(id);\n    if (!node)\n        throw internalError(\"ast node map lookup failed\");\n    if (node.type != requiredType)\n        throw internalError(`ast node map lookup failed: expected a node of type '${requiredType}' but got a '${node.type}' node`);\n    //@ts-ignore\n    return node;\n}\nexport function getASTExpr(ctx, id) {\n    const node = ctx.astNodes.get(id);\n    if (!node)\n        throw internalError(\"ast node map lookup failed\");\n    const asexpr = asExpr(node);\n    if (!asexpr.success)\n        throw internalError(\"ast node map lookup failed: expected an expression but got a non-expression\");\n    return asexpr.data;\n}\nexport function typecheckPoint(expr, ctx) {\n    const x = typecheckExpr(expr.x, ctx);\n    const y = typecheckExpr(expr.y, ctx);\n    const err = consolidateTypeErrors([x, y]);\n    if (err)\n        return err;\n    if (x.type != \"number\")\n        return wrongTypeError(expr.x, ctx.unitName, \"expected a number\");\n    if (y.type != \"number\")\n        return wrongTypeError(expr.y, ctx.unitName, \"expected a number\");\n    return { type: \"point\" };\n}\nexport function addVarsToCtx(ctx, vars) {\n    const newVars = new Map(ctx.knownTypes);\n    for (const [k, v] of vars.entries()) {\n        newVars.set(k, v);\n    }\n    return { ...ctx, knownTypes: newVars };\n}\nexport function typecheckListcomp(expr, ctx) {\n    const vars = new Map();\n    const paramTypes = expr.params.map((p) => [p[0], typecheckExpr(p[1], ctx), p[1]]);\n    const err = consolidateTypeErrors([...paramTypes.map((t) => t[1])]);\n    if (err)\n        return err;\n    for (const [pname, ptype, p] of paramTypes) {\n        if (ptype.type != \"list\")\n            return wrongTypeError(p, ctx.unitName, `list comprehension parameters must be lists, but '${pname}', an expression of type '${typeAsStr(ptype)}', was received instead`);\n        // add scope content to the list of known variable types\n        // to parse inner expression\n        const varScopeContent = expr.innerScope.elements.get(pname);\n        vars.set(varScopeContent.id, ptype.element);\n    }\n    const body = typecheckExpr(expr.body, addVarsToCtx(ctx, vars));\n    const err2 = consolidateTypeErrors([body]);\n    if (err2)\n        return err2;\n    if (body.type == \"list\")\n        return wrongTypeError(expr.body, ctx.unitName, \"list comprehension body cannot be a list, as desmos does not support nested lists\");\n    return { type: \"list\", element: body };\n}\nexport function typecheckIdentifier(expr, ctx) {\n    const enclosingScope = expr.enclosingScope;\n    const identifierScopeItem = findIdentifierScopeItem(ctx.units.get(ctx.unitName), enclosingScope, expr.segments, { compilationUnits: ctx.units });\n    // point member accesses always return numbers\n    if (identifierScopeItem.result == \"point-member-access\") {\n        return { type: \"number\" };\n        // it's an error if an identifier is not found\n    }\n    else if (identifierScopeItem.result == \"not-found\") {\n        return notFoundError(expr, ctx.unitName, `identifier '${expr.segments.join(\".\")}' does not exist`);\n    }\n    if (ctx.knownCircularDependencies.has(identifierScopeItem.identifier.id)) {\n        return { type: \"error\", why: [] };\n    }\n    // did we find a custom defined variable?\n    if (identifierScopeItem.identifier.type == \"variable\") {\n        // check to see if there's a circular dependency\n        if (ctx.dependencyChain.has(identifierScopeItem.identifier.id)) {\n            return formatCircularDependencyError(expr, ctx.units, ctx.dependencyChain, identifierScopeItem.identifier, ctx.knownCircularDependencies);\n        }\n        // get the variable assignment that created this variable\n        const identifierBodyExpr = getASTNode(ctx, identifierScopeItem.identifier.node, \"assignment\");\n        // add the new variable to a copy of the dependency chain\n        // this is to prevent circular dependencies down the line\n        const dependencyChain = new Map(ctx.dependencyChain);\n        dependencyChain.set(identifierScopeItem.identifier.id, {\n            content: identifierScopeItem.identifier,\n            node: expr,\n            nodeUnit: ctx.unitName,\n        });\n        // typecheck the assignment rhs and treat that as the type\n        const identifierType = typecheckExpr(identifierBodyExpr.rhs, {\n            ...ctx,\n            dependencyChain,\n        });\n        return identifierType;\n        // did we find a built-in variable?\n    }\n    else if (identifierScopeItem.identifier.type == \"builtin-variable\") {\n        // builtin variables' types are provided by other expressions\n        // (e.g. function calls or list comprehensions)\n        // so knownTypes must contain them\n        if (identifierScopeItem.identifier.typeSignature)\n            return identifierScopeItem.identifier.typeSignature;\n        const type = ctx.knownTypes.get(identifierScopeItem.identifier.id);\n        if (!type)\n            throw internalError(`builtin variables should have their types provided! builtin variable was ${expr.segments.join(\".\")}`);\n        return type;\n    }\n    else {\n        return wrongTypeError(expr, ctx.unitName, `expected an identifier representing a variable but found a/an ${formatScopeItemTypeName(identifierScopeItem.identifier.type)} instead`);\n    }\n}\nexport function typecheckList(expr, ctx) {\n    if (expr.elements.length == 0) {\n        if (!expr.typeAnnotation)\n            throw internalError(\"Expected a type annotation, as this is an empty list! This should be caught during parsing!\");\n        return { type: expr.typeAnnotation };\n    }\n    const elemTypes = expr.elements.map((e) => typecheckExpr(e, ctx));\n    const err = consolidateTypeErrors(elemTypes);\n    if (err)\n        return err;\n    let elemType = elemTypes[0];\n    if (elemType.type == \"list\") {\n        return wrongTypeError(expr.elements[0], ctx.unitName, \"desmoscript does not support lists of lists\");\n    }\n    for (const elem of expr.elements.slice(1)) {\n        const thisElemType = typecheckExpr(elem, ctx);\n        if (thisElemType.type != elemType.type)\n            return wrongTypeError(elem, ctx.unitName, `based on its first element, this is a list of ${elemType.type}s, but this element is of type '${typeAsStr(thisElemType)}'`);\n    }\n    return { type: \"list\", element: elemType };\n}\nexport function getInnerDefinedVariable(expr, name) {\n    const innerScope = expr.innerScope;\n    const content = innerScope.elements.get(name);\n    if (!content)\n        throw internalError(`expected '${name}' to be defined in this inner scope`);\n    if (content.type != \"builtin-variable\")\n        throw internalError(`expected '${name}' to be a builtin variable`);\n    return content;\n}\nexport function typecheckFnCall(expr, ctx) {\n    // find fndef\n    const fndefFindResult = findIdentifierScopeItem(ctx.units.get(ctx.unitName), expr.enclosingScope, expr.name.segments, { compilationUnits: ctx.units });\n    // if not found, throw an error\n    if (fndefFindResult.result != \"found\") {\n        return notFoundError(expr.name, ctx.unitName, `could not find a function with the name '${expr.name.segments.join(\".\")}'`);\n    }\n    const fndefScopeContent = fndefFindResult.identifier;\n    const paramTypes = [];\n    // no need to consolidate errors because this will be resolved downstream\n    for (const p of expr.params) {\n        paramTypes.push(typecheckExpr(p, ctx));\n    }\n    // if function is user-defined (not builtin)\n    if (fndefScopeContent.type == \"function\") {\n        if (ctx.dependencyChain.has(fndefScopeContent.id)) {\n            return formatCircularDependencyError(expr, ctx.units, ctx.dependencyChain, fndefScopeContent, ctx.knownCircularDependencies);\n        }\n        const fndefStmt = getASTNode(ctx, fndefScopeContent.node, \"fndef\");\n        const params = fndefStmt.params;\n        // validate number of parameters is correct\n        if (params.length != expr.params.length) {\n            return wrongTypeError(expr, ctx.unitName, `wrong number of parameters: function '${expr.name.segments.join(\".\")}' takes ${params.length} parameters, but it was given ${expr.params.length} parameters here`);\n        }\n        // set types of parameters\n        const knownTypes = new Map();\n        for (let i = 0; i < params.length; i++) {\n            const paramID = getInnerDefinedVariable(fndefStmt, params[i]).id;\n            knownTypes.set(paramID, paramTypes[i]);\n        }\n        const dependencyChain = new Map(ctx.dependencyChain);\n        dependencyChain.set(fndefScopeContent.id, {\n            content: fndefScopeContent,\n            node: fndefStmt,\n            nodeUnit: ctx.unitName,\n        });\n        const result = typecheckExpr(fndefStmt.body, addVarsToCtx({ ...ctx, dependencyChain }, knownTypes));\n        if (result.type == \"error\") {\n            return {\n                type: \"error\",\n                why: [\n                    {\n                        type: \"bad-fncall\",\n                        reason: `cannot call '${expr.name.segments.join(\".\")}' due to bad parameters because:`,\n                        start: expr.start,\n                        end: expr.end,\n                        why: result.why,\n                        unit: ctx.unitName,\n                    },\n                ],\n            };\n        }\n        return result;\n        // if function is not user-defined (builtin)\n    }\n    else if (fndefScopeContent.type == \"builtin-function\") {\n        return typecheckBuiltinFn(expr, paramTypes, fndefScopeContent, ctx);\n    }\n    else {\n        return wrongTypeError(expr.name, ctx.unitName, `expected this name to refer to a function; got a/an ${formatScopeItemTypeName(fndefScopeContent.type)} instead`);\n    }\n}\nexport function typecheckBlock(expr, ctx) {\n    const lastNode = expr.body[expr.body.length - 1];\n    if (!lastNode)\n        return wrongTypeError(expr, ctx.unitName, \"a block must contain at least one expression for it to be a valid expression (i.e. something that resolves to a value)\");\n    const maybeLastExpr = asExpr(lastNode);\n    if (!maybeLastExpr.success)\n        return wrongTypeError(lastNode, ctx.unitName, \"this statement is the last one within a block expression and therefore must also be an expression (something that resolves to a value)\");\n    const lastExpr = maybeLastExpr.data;\n    return typecheckExpr(lastExpr, ctx);\n}\nexport function typecheckMatch(expr, ctx) {\n    const branchTypes = expr.branches.map((b) => [b[0], b[1], typecheckExpr(b[0], ctx), typecheckExpr(b[1], ctx)]);\n    const fallbackType = expr.fallback\n        ? typecheckExpr(expr.fallback, ctx)\n        : undefined;\n    const type = branchTypes[0]?.[3] ?? fallbackType ?? { type: \"number\" };\n    const errs = [];\n    const testBranch = (branch, branchType) => {\n        if (branchType.type != type.type)\n            errs.push(wrongTypeError(branch, ctx.unitName, `all match branches must resolve to the same type; expected a ${typeAsStr(type)} based on the first branch but got a ${typeAsStr(branchType)}`));\n    };\n    for (const [condExpr, branchExpr, condType, branchType] of branchTypes) {\n        if (condType.type != \"boolean\") {\n            errs.push(wrongTypeError(condExpr, ctx.unitName, `expected a boolean, got a ${typeAsStr(condType)}`));\n        }\n        testBranch(branchExpr, branchType);\n    }\n    if (expr.fallback && fallbackType)\n        testBranch(expr.fallback, fallbackType);\n    const err = consolidateTypeErrors([branchTypes.map((b) => [b[2], b[3]]), fallbackType ?? []].flat(2));\n    if (err)\n        return err;\n    return type;\n}\nexport function typecheckRange(expr, ctx) {\n    const lhsType = typecheckExpr(expr.lhs, ctx);\n    const rhsType = typecheckExpr(expr.rhs, ctx);\n    const stepType = expr.step ? typecheckExpr(expr.step, ctx) : undefined;\n    const err = consolidateTypeErrors([lhsType, rhsType].concat(stepType ? [stepType] : []));\n    if (err)\n        return err;\n    for (const [e, t] of [\n        [expr.lhs, lhsType],\n        [expr.rhs, rhsType],\n    ].concat(stepType && expr.step ? [[expr.step, stepType]] : [])) {\n        if (t.type == \"number\")\n            continue;\n        return wrongTypeError(e, ctx.unitName, `range arguments must be numbers but a ${typeAsStr(t)} was received instead`);\n    }\n    return { type: \"list\", element: { type: \"number\" } };\n}\nexport function typecheckUnop(expr, ctx) {\n    const operandType = typecheckExpr(expr.operand, ctx);\n    if (operandType.type == \"error\")\n        return operandType;\n    switch (expr.op) {\n        case \"!\":\n            if (operandType.type != \"boolean\")\n                return wrongTypeError(expr.operand, ctx.unitName, `expected a boolean; got a ${typeAsStr(operandType)}`);\n            return { type: \"boolean\" };\n        case \"-\":\n            if ([\"number\", \"point\"].indexOf(operandType.type == \"list\"\n                ? operandType.element.type\n                : operandType.type) == -1) {\n                return wrongTypeError(expr.operand, ctx.unitName, `cannot negate a ${typeAsStr(operandType)}`);\n            }\n            return operandType;\n        case \".x\":\n        case \".y\":\n            if (operandType.type != \"point\")\n                return wrongTypeError(expr.operand, ctx.unitName, `cannot access the ${expr.op[1]} component of a ${typeAsStr(operandType)} or anything else that isn't a point`);\n            return { type: \"number\" };\n    }\n}\nexport function typecheckMacrocall(expr, ctx) {\n    const result = expr.result;\n    if (!result)\n        return wrongTypeError(expr, ctx.unitName, `unresolved macro!`);\n    if (result instanceof Promise)\n        return wrongTypeError(expr, ctx.unitName, `unawaited macro!`);\n    const resultErrors = getErrors(result);\n    if (resultErrors.length > 0) {\n        return badMacroError(expr, resultErrors, ctx.unitName, \"error in macro body\");\n    }\n    const maybeResultExpr = asExpr(result);\n    if (maybeResultExpr.success) {\n        return typecheckExpr(maybeResultExpr.data, ctx);\n    }\n    return wrongTypeError(expr, ctx.unitName, `expected this macro to resolve to an expression, but received '${formatAST(result, { indent: 2, tabSize: 2, maxlen: 80, bindingPower: 0 })}' instead`);\n}\nexport function typecheckExpr(expr, ctx) {\n    switch (expr.type) {\n        case \"binop\":\n            return typecheckBinop(expr, ctx);\n        case \"block\":\n            return typecheckBlock(expr, ctx);\n        case \"error\":\n            return {\n                type: \"error\",\n                why: [\n                    {\n                        type: \"wrong-type\",\n                        start: expr.start,\n                        end: expr.end,\n                        unit: expr.unitName,\n                        reason: expr.reason,\n                    },\n                ],\n            };\n        case \"fncall\":\n            return typecheckFnCall(expr, ctx);\n        case \"identifier\":\n            return typecheckIdentifier(expr, ctx);\n        case \"list\":\n            return typecheckList(expr, ctx);\n        case \"listcomp\":\n            return typecheckListcomp(expr, ctx);\n        case \"macrocall\":\n            return typecheckMacrocall(expr, ctx);\n        case \"match\":\n            return typecheckMatch(expr, ctx);\n        case \"note\":\n            return wrongTypeError(expr, ctx.unitName, \"a note cannot be used in this context\");\n        case \"number\":\n            return { type: \"number\" };\n        case \"range\":\n            return typecheckRange(expr, ctx);\n        case \"unop\":\n            return typecheckUnop(expr, ctx);\n        case \"point\":\n            return typecheckPoint(expr, ctx);\n    }\n}\nexport function typecheckScopeTree(scope, ctx, types) {\n    if (!types)\n        types = [];\n    for (const [itemName, item] of scope.elements) {\n        switch (item.type) {\n            case \"function\":\n                // types.push(\n                //   typecheckExpr(\n                //     getASTNode<FunctionDefNode, \"fndef\">(ctx, item.node, \"fndef\").body,\n                //     ctx\n                //   )\n                // );\n                break;\n            case \"variable\":\n                const node = getASTNode(ctx, item.node, \"assignment\");\n                types.push(typecheckExpr(node.rhs, ctx));\n                break;\n            case \"expression\":\n                types.push(typecheckExpr(getASTExpr(ctx, item.expr), ctx));\n                break;\n            case \"scope\":\n                if (!item.isWithinFunction)\n                    typecheckScopeTree(item.scope, ctx, types);\n                break;\n            case \"import\":\n                typecheckScopeTree(assertNotUndefined(ctx.units.get(item.compilationUnitPath), `'${item.compilationUnitPath}' not found in typecheckScopeTree`).scopeTree, { ...ctx, unitName: item.compilationUnitPath }, types);\n                break;\n        }\n    }\n    return consolidateTypeErrors(types);\n}\n","import { z } from \"zod\";\nexport const baseItemStateParser = z.object({\n    id: z.string(),\n    secret: z.boolean().optional(),\n});\nexport const baseNonFolderStateParser = z.intersection(baseItemStateParser, z.object({\n    folderId: z.string().optional(),\n}));\nexport const lineStyleParser = z.union([z.literal(\"SOLID\"), z.literal(\"DASHED\"), z.literal(\"DOTTED\")], {});\nexport const pointStyleParser = z.union([z.literal(\"POINT\"), z.literal(\"OPEN\"), z.literal(\"CROSS\")], {});\nexport const dragModeParser = z.union([\n    z.literal(\"NONE\"),\n    z.literal(\"X\"),\n    z.literal(\"Y\"),\n    z.literal(\"XY\"),\n    z.literal(\"AUTO\"),\n], {});\nexport const labelSizeParser = z.union([z.literal(\"SMALL\"), z.literal(\"MEDIUM\"), z.literal(\"LARGE\"), z.string()], {});\nexport const labelOrientationParser = z.union([\n    z.literal(\"default\"),\n    z.literal(\"center\"),\n    z.literal(\"center_auto\"),\n    z.literal(\"auto_center\"),\n    z.literal(\"above\"),\n    z.literal(\"above_left\"),\n    z.literal(\"above_right\"),\n    z.literal(\"above_auto\"),\n    z.literal(\"below\"),\n    z.literal(\"below_left\"),\n    z.literal(\"below_right\"),\n    z.literal(\"below_auto\"),\n    z.literal(\"left\"),\n    z.literal(\"auto_left\"),\n    z.literal(\"right\"),\n    z.literal(\"auto_right\"),\n], {});\nexport const domainParser = z.object({\n    min: z.string(),\n    max: z.string(),\n});\nexport const baseClickableParser = z.object({\n    enabled: z.boolean().optional(),\n    description: z.string().optional(),\n    latex: z.string().optional(),\n});\nexport const expressionStateWithoutColumnParser = z.object({\n    type: z.literal(\"expression\"),\n    showLabel: z.boolean().optional(),\n    fill: z.boolean().optional(),\n    fillOpacity: z.string().optional(),\n    label: z.string().optional(),\n    labelSize: labelSizeParser.optional(),\n    labelOrientation: labelOrientationParser.optional(),\n    labelAngle: z.string().optional(),\n    suppressTextOutline: z.boolean().optional(),\n    interactiveLabel: z.boolean().optional(),\n    editableLabelMode: z.union([z.literal(\"MATH\"), z.literal(\"TEXT\")]).optional(),\n    residualVariable: z.string().optional(),\n    regressionParameters: z.record(z.string(), z.number()).optional(),\n    isLogModeRegression: z.boolean().optional(),\n    displayEvaluationAsFraction: z.boolean().optional(),\n    slider: z\n        .object({\n        hardMin: z.boolean().optional(),\n        hardMax: z.boolean().optional(),\n        animationPeriod: z.number().optional(),\n        loopMode: z\n            .union([\n            z.literal(\"LOOP_FORWARD_REVERSE\"),\n            z.literal(\"LOOP_FORWARD\"),\n            z.literal(\"PLAY_ONCE\"),\n            z.literal(\"PLAY_INDEFINITELY\"),\n        ])\n            .optional(),\n        playDirection: z.union([z.literal(-1), z.literal(1)]).optional(),\n        isPlaying: z.boolean().optional(),\n        min: z.string().optional(),\n        max: z.string().optional(),\n        step: z.string().optional(),\n    })\n        .optional(),\n    polarDomain: domainParser.optional(),\n    parametricDomain: domainParser.optional(),\n    domain: domainParser.optional(),\n    cdf: z\n        .object({\n        show: z.boolean(),\n        min: z.string().optional(),\n        max: z.string().optional(),\n    })\n        .optional(),\n    vizProps: z\n        .object({\n        breadth: z.string().optional(),\n        axisOffset: z.string().optional(),\n        alignedAxis: z.union([z.literal(\"x\"), z.literal(\"y\")]).optional(),\n        showBoxplotOutliers: z.boolean().optional(),\n        dotplotXMode: z\n            .union([z.literal(\"exact\"), z.literal(\"binned\")])\n            .optional(),\n        binAlignment: z\n            .union([z.literal(\"left\"), z.literal(\"center\")])\n            .optional(),\n        histogramMode: z\n            .union([\n            z.literal(\"count\"),\n            z.literal(\"relative\"),\n            z.literal(\"density\"),\n        ])\n            .optional(),\n    })\n        .optional(),\n    clickableInfo: baseClickableParser.optional(),\n});\nexport const columnExpressionSharedParser = z.object({\n    color: z.string(),\n    latex: z.string().optional(),\n    hidden: z.boolean().optional(),\n    points: z.boolean().optional(),\n    lines: z.boolean().optional(),\n    dragMode: dragModeParser.optional(),\n    lineStyle: lineStyleParser.optional(),\n    pointStyle: pointStyleParser.optional(),\n    colorLatex: z.string().optional(),\n    lineOpacity: z.string().optional(),\n    lineWidth: z.string().optional(),\n    pointSize: z.string().optional(),\n    pointOpacity: z.string().optional(),\n});\nexport const expressionStateParser = expressionStateWithoutColumnParser.merge(columnExpressionSharedParser);\nexport const imageStateParser = z.object({\n    type: z.literal(\"image\"),\n    image_url: z.string(),\n    name: z.string().optional(),\n    width: z.string().optional(),\n    height: z.string().optional(),\n    hidden: z.boolean().optional(),\n    center: z.string().optional(),\n    angle: z.string().optional(),\n    opacity: z.string().optional(),\n    foreground: z.boolean().optional(),\n    draggable: z.boolean().optional(),\n    clickableInfo: z.intersection(baseClickableParser, z.object({\n        hoveredImage: z.string().optional(),\n        depressedImage: z.string().optional(),\n    })),\n});\nexport const tableColumnParser = z.intersection(z.object({\n    id: z.string(),\n    values: z.array(z.string()),\n}), columnExpressionSharedParser);\nexport const tableStateParser = z.intersection(baseNonFolderStateParser, z.object({\n    type: z.literal(\"table\"),\n    columns: z.array(tableColumnParser),\n}));\nexport const folderStateParser = z.intersection(baseItemStateParser, z.object({\n    type: z.literal(\"folder\"),\n    hidden: z.boolean().optional(),\n    collapsed: z.boolean().optional(),\n    title: z.string().optional(),\n}));\nexport const textStateParser = z.intersection(baseNonFolderStateParser, z.object({\n    type: z.literal(\"text\"),\n    text: z.string().optional(),\n}));\nexport const arrowModeParser = z.union([z.literal(\"NONE\"), z.literal(\"POSITIVE\"), z.literal(\"BOTH\")], {});\nexport const GrapherStateParser = z\n    .object({\n    viewport: z\n        .object({\n        xmin: z.number(),\n        ymin: z.number(),\n        xmax: z.number(),\n        ymax: z.number(),\n    })\n        .strict(),\n    xAxisMinorSubdivisions: z.number().optional(),\n    yAxisMinorSubdivisions: z.number().optional(),\n    degreeMode: z.boolean().optional(),\n    showGrid: z.boolean().optional(),\n    showXAxis: z.boolean().optional(),\n    showYAxis: z.boolean().optional(),\n    xAxisNumbers: z.boolean().optional(),\n    yAxisNumbers: z.boolean().optional(),\n    polarNumbers: z.boolean().optional(),\n    xAxisStep: z.number().optional(),\n    yAxisStep: z.number().optional(),\n    xAxisArrowMode: arrowModeParser.optional(),\n    yAxisArrowMode: arrowModeParser.optional(),\n    xAxisLabel: z.string().optional(),\n    yAxisLabel: z.string().optional(),\n    squareAxes: z.boolean().optional(),\n    restrictGridToFirstQuadrant: z.boolean().optional(),\n    polarMode: z.boolean().optional(),\n    userLockedViewport: z.boolean().optional(),\n})\n    .strict();\nexport const nonFolderStateParser = z.union([\n    expressionStateParser,\n    imageStateParser,\n    tableStateParser,\n    textStateParser,\n]);\nexport const tickerParser = z.object({\n    handlerLatex: z.string().optional(),\n    minStepLatex: z.string().optional(),\n    open: z.boolean().optional(),\n    playing: z.boolean().optional(),\n});\nexport const itemStateParser = z.union([nonFolderStateParser, folderStateParser], {});\nexport const GraphStateParser = z.object({\n    version: z.literal(9),\n    randomSeed: z.string().optional(),\n    graph: GrapherStateParser,\n    expressions: z.object({\n        list: z.array(itemStateParser),\n        ticker: z.optional(tickerParser),\n    }),\n});\n","import { asExpr, newid, } from \"../ast/ast\";\nimport { formatAST } from \"../ast/fmt\";\nimport { assertNotUndefined, internalError } from \"../compiler-errors\";\nimport { debugPrint, debugTrace } from \"../debug/debug\";\nimport { findIdentifierScopeItem, getScopeNameList, } from \"../scope-tree/create-scope-tree\";\nimport { wrongTypeError } from \"../scope-tree/typecheck/type-errors\";\nimport { getASTExpr, getASTNode } from \"../scope-tree/typecheck/typecheck\";\nimport { GrapherStateParser, tickerParser, expressionStateParser, } from \"./graphstate\";\nexport function desmosifyName(str) {\n    if (str.length <= 1)\n        return str;\n    return `${str[0]}_{${str.slice(1)}}`;\n}\nexport function capitalizeFirst(str) {\n    return str[0].toUpperCase() + str.slice(1);\n}\nexport function getNameForIdentifier(identifierPath, startScope, ctx) {\n    const scopeItem = findIdentifierScopeItem(ctx.units.get(ctx.currentUnit), startScope, identifierPath, { compilationUnits: ctx.units });\n    if (scopeItem.result != \"found\") {\n        if (scopeItem.result == \"point-member-access\") {\n            return `${getNameForIdentifier(identifierPath.slice(0, -1), startScope, ctx)}.${identifierPath[identifierPath.length - 1]}`;\n        }\n        debugTrace();\n        debugPrint(startScope);\n        throw internalError(\"TODO\" + identifierPath.join(\".\"));\n    }\n    const scopeNamePath = getScopeNameList(startScope).reverse();\n    // add variable/function name\n    if (scopeItem.identifier.type == \"function\") {\n        scopeNamePath.splice(0, 0, getASTNode(ctx, scopeItem.identifier.node, \"fndef\").name);\n    }\n    else if (scopeItem.identifier.type == \"variable\") {\n        scopeNamePath.splice(0, 0, getASTNode(ctx, scopeItem.identifier.node, \"assignment\").lhs);\n        // if it's a builtin, early return the custom desmos-specific name if it's defined by desmos\n    }\n    else if (scopeItem.identifier.type == \"builtin-function\") {\n        if (scopeItem.identifier.definedByDesmos) {\n            return `\\\\operatorname{${identifierPath[identifierPath.length - 1]}}`;\n        }\n        else {\n            scopeNamePath.splice(0, 0, identifierPath[identifierPath.length - 1]);\n        }\n    }\n    else if (scopeItem.identifier.type == \"builtin-variable\") {\n        if (scopeItem.identifier.definedByDesmos) {\n            return identifierPath[identifierPath.length - 1];\n        }\n        else {\n            scopeNamePath.splice(0, 0, identifierPath[identifierPath.length - 1]);\n        }\n    }\n    // add compilation unit name to scope name path\n    // to further disambiguate names\n    scopeNamePath.push(ctx.currentUnit.split(\"/\").reverse()[0].replace(\".desmo\", \"\"));\n    // if name already exists, then use it\n    const name = ctx.identifierNames.get(scopeItem.identifier.id);\n    if (name)\n        return desmosifyName(name);\n    // keep appending segments until name is no longer in use\n    let proposedName = \"\";\n    const addProposedName = () => {\n        ctx.existingNames.add(proposedName);\n        ctx.identifierNames.set(scopeItem.identifier.id, proposedName);\n    };\n    for (const identPathElem of scopeNamePath) {\n        proposedName = capitalizeFirst(identPathElem) + proposedName;\n        if (!ctx.existingNames.has(proposedName)) {\n            addProposedName();\n            return desmosifyName(proposedName);\n        }\n    }\n    // keep appending numbers until a free one is found\n    let proposedNameWithoutNumber = proposedName;\n    let i = 2;\n    while (true) {\n        proposedName = proposedNameWithoutNumber + i;\n        if (!ctx.existingNames.has(proposedName)) {\n            addProposedName();\n            return desmosifyName(proposedName);\n        }\n        i++;\n    }\n}\nexport function generateExprCode(e, ctx) {\n    const c = (e) => generateExprCode(e, ctx);\n    switch (e.type) {\n        case \"binop\":\n            const l = c(e.lhs);\n            const r = c(e.rhs);\n            switch (e.op) {\n                case \"+\":\n                case \"-\":\n                case \"*\":\n                    return `\\\\left(${l}${e.op}${r}\\\\right)`;\n                case \"/\":\n                    return `\\\\frac{${l}}{${r}}`;\n                case \"^\":\n                    return `${l}^{${r}}`;\n                case \"%\":\n                    return `\\\\operatorname{mod}\\\\left(${l},${r}\\\\right)`;\n                case \"<\":\n                case \">\":\n                case \"==\":\n                    return `${l}${e.op}${r}`;\n                case \">=\":\n                    return `${l}\\\\ge ${r}`;\n                case \"<=\":\n                    return `${l}\\\\le ${r}`;\n                case \"[\":\n                    return `\\\\left(${l}\\\\right)\\\\left[${r}\\\\right]`;\n                default:\n                    throw internalError(`UNIMPLEMENTED BINARY OP: ${e.op}`);\n            }\n        case \"block\":\n            const lastNode = e.body[e.body.length - 1];\n            if (!lastNode)\n                throw internalError(`NO EMPTY BLOCKS IN CODEGEN!`);\n            const maybeLastExpr = asExpr(lastNode);\n            if (!maybeLastExpr.success)\n                throw internalError(`EMPTY BLOCKS MUST END IN EXPRESSIONS IN CODEGEN`);\n            ctx.alreadyGeneratedBlockFinalExpressionIDs.add(lastNode.id);\n            return c(maybeLastExpr.data);\n        case \"error\":\n            // TODO: find an acutally sensible way to handle this\n            return \"ERROR\";\n        //throw internalError(`NO ERROR NODES IN CODEGEN`);\n        case \"fncall\":\n            return `${c(e.name)}\\\\left(${e.params\n                .map((p) => c(p))\n                .join(\",\")}\\\\right)`;\n        case \"identifier\":\n            return getNameForIdentifier(e.segments, e.enclosingScope, ctx);\n        case \"list\":\n            return `\\\\left[${e.elements.map((e) => c(e)).join(\",\")}\\\\right]`;\n        case \"listcomp\":\n            return `\\\\left[${c(e.body)} \\\\operatorname{for} ${e.params\n                .map(([v, p]) => {\n                return `${getNameForIdentifier([v], e.innerScope, ctx)}=${c(p)}`;\n            })\n                .join(\",\")}\\\\right]`;\n        case \"macrocall\":\n            const result = e.result;\n            if (!result || result instanceof Promise)\n                throw internalError(\"UNRESOLVED MACRO\");\n            const resultExpr = asExpr(result);\n            if (resultExpr.success && resultExpr.data.type != \"note\") {\n                return c(resultExpr.data);\n            }\n            else {\n                return \"ERROR\";\n            }\n        // else {\n        //   throw internalError(\n        //     \"TODO: come up with proper error handling for codegen\"\n        //   );\n        // }\n        case \"match\":\n            return `\\\\left\\\\{${e.branches\n                .map(([cond, value]) => `${c(cond)}:${c(value)}`)\n                .join(\",\")}${e.fallback ? `,${c(e.fallback)}` : \"\"}\\\\right\\\\}`;\n        case \"note\":\n            throw internalError(`NO NOTES IN CODEGEN`);\n        case \"number\":\n            return e.number.toString();\n        case \"point\":\n            return `\\\\left(${c(e.x)},${c(e.y)}\\\\right)`;\n        case \"range\":\n            if (e.step) {\n                return `\\\\left[${c(e.lhs)},${c(e.step)}...${c(e.rhs)}\\\\right]`;\n            }\n            else {\n                return `\\\\left[${c(e.lhs)}...${c(e.rhs)}\\\\right]`;\n            }\n        case \"unop\":\n            if (e.op == \"!\")\n                throw internalError(\"UNIMPLEMENTED UNARY OP: !\");\n            if (e.op == \".x\" || e.op == \".y\")\n                return `\\\\left(${c(e.operand)}\\\\right)${e.op}`;\n            if (e.op == \"-\")\n                return `-\\\\left(${c(e.operand)}\\\\right)`;\n    }\n    throw internalError(\"UNREACHABLE\");\n}\nexport function compileJSON(e, ctx) {\n    switch (e.type) {\n        case \"number\":\n            return e.number;\n        case \"note\":\n            return e.content;\n        case \"json-array\":\n            return e.elements.map((f) => compileJSON(f, ctx));\n        case \"json-boolean\":\n            return e.data;\n        case \"json-object\":\n            return Object.fromEntries(e.data.map(([k, v]) => [k, compileJSON(v, ctx)]));\n        case \"json-null\":\n            return null;\n        case \"json-inner-expr\":\n            return generateExprCode(e.expr, ctx);\n        case \"error\":\n            throw internalError(\"ERROR NODE IN JSON\");\n    }\n}\nexport function defaultGraphstate() {\n    return {\n        version: 9,\n        graph: {\n            viewport: {\n                xmin: -10,\n                ymin: -10,\n                xmax: 10,\n                ymax: 10,\n            },\n        },\n        expressions: {\n            list: [],\n        },\n    };\n}\nexport function getJsonNode(ctx, id) {\n    const node = ctx.astNodes.get(id);\n    if (!node)\n        throw internalError(\"expected a node to exist\");\n    if (node.type == \"json-array\")\n        return node;\n    if (node.type == \"json-boolean\")\n        return node;\n    if (node.type == \"json-object\")\n        return node;\n    if (node.type == \"number\")\n        return node;\n    if (node.type == \"note\")\n        return node;\n    if (node.type == \"json-inner-expr\")\n        return node;\n    if (node.type == \"json-null\")\n        return node;\n    throw internalError(\"expected a json expression\");\n}\nexport function generateCodeForScopeTree(ctx, scope) {\n    if (ctx.options.allInOneFolderID !== undefined) {\n        ctx.folderState = { id: ctx.options.allInOneFolderID, name: \"\" };\n    }\n    const addFolder = () => {\n        if (ctx.options.allInOneFolderID !== undefined)\n            return;\n        if (!ctx.folderState)\n            return;\n        ctx.state.expressions.list.push({\n            id: ctx.folderState.id,\n            title: ctx.folderState.name,\n            type: \"folder\",\n        });\n    };\n    const getDisplay = (node) => {\n        const parsedItemState = expressionStateParser\n            .partial()\n            .safeParse(compileJSON(node, ctx));\n        if (!parsedItemState.success) {\n            ctx.errors.push({\n                type: \"bad-json\",\n                node,\n                start: node.start,\n                end: node.end,\n                unit: ctx.currentUnit,\n                reason: \"\", //fromZodError(parsedItemState.error).message,\n            });\n            return {};\n        }\n        else {\n            return parsedItemState.data;\n        }\n    };\n    const maybeGetDisplay = (nodeId) => {\n        if (!nodeId)\n            return {};\n        return getDisplay(getJsonNode(ctx, nodeId));\n    };\n    const addDesmoscriptEquivalent = (node) => {\n        if (!ctx.options.annotateExpressionsWithEquivalentDesmoscript)\n            return;\n        ctx.state.expressions.list.push({\n            id: newid().toString(),\n            type: \"text\",\n            text: formatAST(node, {\n                indent: 2,\n                tabSize: 2,\n                maxlen: 80,\n                bindingPower: 0,\n            }),\n            folderId: ctx.folderState?.id,\n        });\n    };\n    for (const item of scope.imports) {\n        generateCodeForCompilationUnit({\n            ...ctx,\n            currentUnit: item.compilationUnitPath,\n        });\n    }\n    for (const [itemName, item] of scope.elements.entries()) {\n        switch (item.type) {\n            // add variable to the expression list\n            case \"variable\":\n                const assignment = getASTNode(ctx, item.node, \"assignment\");\n                addDesmoscriptEquivalent(assignment);\n                ctx.state.expressions.list.push({\n                    id: newid().toString(),\n                    type: \"expression\",\n                    color: \"black\",\n                    latex: `${getNameForIdentifier([itemName], scope, ctx)}=${generateExprCode(assignment.rhs, ctx)}`,\n                    folderId: ctx.folderState?.id,\n                    ...maybeGetDisplay(item.display),\n                });\n                break;\n            // add function to the expression list\n            case \"function\":\n                const astNode = getASTNode(ctx, item.node, \"fndef\");\n                addDesmoscriptEquivalent(astNode);\n                ctx.state.expressions.list.push({\n                    latex: `${getNameForIdentifier([itemName], scope, ctx)}\\\\left(${astNode.params.map((p) => getNameForIdentifier([p], astNode.innerScope, ctx))}\\\\right)=${generateExprCode(astNode.body, ctx)}`,\n                    id: newid().toString(),\n                    type: \"expression\",\n                    color: \"black\",\n                    folderId: ctx.folderState?.id,\n                    ...maybeGetDisplay(item.display),\n                });\n                break;\n            // add scope to the expression list\n            case \"scope\":\n                if (item.scope.elements.size == 0)\n                    break;\n                const oldFolderState = ctx.folderState;\n                const newFolderState = {\n                    id: newid().toString(),\n                    name: (oldFolderState?.name ?? \"\") +\n                        (oldFolderState ? `/${item.scope.name}` : `${item.scope.name}`),\n                };\n                ctx.folderState = newFolderState;\n                addFolder();\n                generateCodeForScopeTree(ctx, item.scope);\n                ctx.folderState = oldFolderState;\n                break;\n            // add note to expression list\n            case \"note\":\n                ctx.state.expressions.list.push({\n                    type: \"text\",\n                    text: item.text,\n                    id: newid().toString(),\n                    folderId: ctx.folderState?.id,\n                });\n                break;\n            // compile a different file\n            case \"import\": {\n                // const oldFolderState = ctx.folderState;\n                // ctx.folderState = undefined;\n                generateCodeForCompilationUnit({\n                    ...ctx,\n                    currentUnit: item.compilationUnitPath,\n                });\n                // ctx.folderState = oldFolderState;\n                // addFolder();\n                break;\n            }\n            // compile settings\n            case \"settings\":\n                const json = compileJSON(getJsonNode(ctx, item.settings), ctx);\n                switch (item.settingsType) {\n                    case \"settings\":\n                        const parsedSettings = GrapherStateParser.safeParse(json);\n                        if (parsedSettings.success) {\n                            ctx.state.graph = parsedSettings.data;\n                        }\n                        else {\n                            throw wrongTypeError(json, ctx.currentUnit, \"failed to set settings for the following reasons: \" +\n                                parsedSettings.error.format()._errors.join(\"\\n\"));\n                        }\n                    case \"ticker\":\n                        const parsedTickerSettings = tickerParser.safeParse(json);\n                        if (parsedTickerSettings.success) {\n                            ctx.state.expressions.ticker = parsedTickerSettings.data;\n                        }\n                        else {\n                            throw wrongTypeError(json, ctx.currentUnit, \"failed to set ticker for the following reasons: \" +\n                                parsedTickerSettings.error.format()._errors.join(\"\\n\"));\n                        }\n                }\n                break;\n            case \"expression\":\n                const expr = getASTExpr(ctx, item.expr);\n                addDesmoscriptEquivalent(expr);\n                if (ctx.alreadyGeneratedBlockFinalExpressionIDs.has(expr.id))\n                    break;\n                ctx.state.expressions.list.push({\n                    type: \"expression\",\n                    id: newid().toString(),\n                    folderId: ctx.folderState?.id,\n                    latex: generateExprCode(expr, ctx),\n                    color: \"black\",\n                    ...maybeGetDisplay(item.display),\n                });\n        }\n    }\n}\nexport function generateCodeForCompilationUnit(ctx) {\n    if (ctx.alreadyCompiledUnits.has(ctx.currentUnit))\n        return;\n    ctx.alreadyCompiledUnits.add(ctx.currentUnit);\n    generateCodeForScopeTree(ctx, assertNotUndefined(ctx.units.get(ctx.currentUnit), `${ctx.currentUnit} not found in generateCodeForCompilationUnit`).scopeTree);\n}\nexport function generateCode(ctx) {\n    generateCodeForCompilationUnit(ctx);\n    if (ctx.options.allInOneFolderID) {\n        ctx.state.expressions.list.splice(0, 0, {\n            type: \"folder\",\n            id: ctx.options.allInOneFolderID,\n            title: \"Desmoscript Compiler Output\",\n        });\n    }\n}\n","import { forEachASTAsync, } from \"../ast/ast\";\nimport { getLinesAndCols } from \"../index\";\nimport { compilerError } from \"../compiler-errors\";\nexport async function resolveFileImports(filename, importer, expr, ctx) {\n    // get absolute path to file\n    const fullpath = ctx.io.resolvePath(ctx.io.dirname(importer), filename);\n    if (ctx.imports.has(fullpath))\n        return;\n    try {\n        // read file and store source code in case there are parse errors\n        // that result in an import being unavailable\n        const src = await ctx.getFile(fullpath);\n        ctx.watchFiles.add(fullpath);\n        ctx.sourceCode.set(fullpath, { src, linesAndCols: getLinesAndCols(src) });\n        // try lex/parse\n        const highlights = [];\n        const ast = ctx.lexAndParse(fullpath, src, ctx.errors, highlights);\n        ctx.highlightsMap?.set(fullpath, highlights);\n        // add import\n        ctx.imports.set(fullpath, {\n            name: fullpath,\n            src,\n            ast: ast,\n        });\n        // recursively find more imports\n        await forEachASTAsync(ast, undefined, async (node) => {\n            if (node.type == \"import\") {\n                await resolveFileImports(node.src, fullpath, node, ctx);\n            }\n            else if (node.type == \"import-script\") {\n                if (!ctx.importScripts.has(node.src)) {\n                    const iscriptFullPath = ctx.io.resolvePath(ctx.io.dirname(importer), node.src);\n                    const iscriptSrc = await ctx.getFile(iscriptFullPath);\n                    ctx.watchFiles.add(iscriptSrc);\n                    //console.log(\"import script source\", iscriptSrc);\n                    try {\n                        const importScript = new Function(\"desmo\", iscriptSrc);\n                        importScript((run) => {\n                            ctx.importScripts.set(iscriptFullPath, {\n                                run,\n                            });\n                        });\n                    }\n                    catch (err) {\n                        ctx.errors.push({\n                            type: \"general\",\n                            start: node.start,\n                            end: node.end,\n                            unit: fullpath,\n                            reason: `failed to load '${node.src}': ${err}'`,\n                        });\n                    }\n                }\n            }\n        });\n    }\n    catch {\n        ctx.errors.push(compilerError(`failed to import '${filename}' (full path: ${fullpath})`, expr?.start ?? 0, expr?.end ?? 0, importer));\n    }\n}\n","import { forEachAST, forEachASTAsync, newid, } from \"../ast/ast\";\nimport { addScopesToAST, findIdentifierScopeItem, } from \"../scope-tree/create-scope-tree\";\nimport { notFoundError, } from \"../scope-tree/typecheck/type-errors\";\nimport { getMacroAPI } from \"./macro-api\";\nexport function instantiateMacros(node, ctx) {\n    const instantiationErrors = [];\n    let instantiated = false;\n    forEachAST(node, undefined, (node) => {\n        if (node.type != \"macrocall\")\n            return;\n        const scope = node.enclosingScope;\n        const scopeItem = findIdentifierScopeItem(ctx.units.get(ctx.unit), scope, node.name.segments, { compilationUnits: ctx.units });\n        const scopedNode = node;\n        if (scopeItem.result == \"not-found\") {\n            instantiationErrors.push(notFoundError(scopedNode, ctx.unit, `the macro '${node.name.segments.join(\".\")}' does not exist`).why[0]);\n            return;\n        }\n        else if (scopeItem.result == \"point-member-access\") {\n            instantiationErrors.push(notFoundError(scopedNode, ctx.unit, `expected a macro; got a number`)\n                .why[0]);\n            return;\n        }\n        if (scopeItem.identifier.type != \"macro\") {\n            instantiationErrors.push(notFoundError(scopedNode, ctx.unit, `expected a macro; got a '${scopeItem.identifier.type}'`).why[0]);\n            return;\n        }\n        // don't instantiate already-instantiated macros\n        if (scopedNode.result)\n            return;\n        instantiated = true;\n        scopedNode.result = scopeItem.identifier.macroOperation(scopedNode, getMacroAPI(ctx.errors, scopedNode, ctx));\n    });\n    return instantiated;\n}\n// actually resolving the macro instantiations is done in a separate pass\n// so that all the async stuff can happen in a non-blocking manner\nexport async function resolveMacros(node, ctx) {\n    await forEachASTAsync(node, undefined, async (node, parentNode) => {\n        // skip non-macrocalls\n        if (node.type != \"macrocall\")\n            return node;\n        // the purpose of this is to wait until all unresolved macros are resolved\n        // and then add scopes to them\n        // so we only need to do this for unresolved macros (i.e. ones that have promises)\n        if (!(node.result instanceof Promise))\n            return parentNode;\n        try {\n            node.result = await node.result;\n        }\n        catch (err) {\n            if (err != \"\")\n                node.result = {\n                    start: node.start,\n                    end: node.end,\n                    id: newid(),\n                    type: \"error\",\n                    reason: \"error during macro evaluation: \" + err?.toString(),\n                    unitName: ctx.unit,\n                };\n        }\n        // // TODO: Find a better way of dealing with this\n        // if (!node.result) {\n        //   return parentNode;\n        // }\n        // macro instantiation result is already an AST; all we have to do is add scopes to it\n        // make sure to pass the parent of the macro call as the \"parent node\" because scope resolution\n        // should not care about whether an expression came from a macro or directly from the source\n        // code\n        node.result = addScopesToAST(node.result, {\n            parentNode,\n            scope: node.enclosingScope,\n        }, {\n            ...ctx,\n            errors: ctx.errors,\n            importScripts: ctx.importScripts,\n            getAbsolutePath: ctx.getAbsolutePath,\n        });\n        return parentNode;\n    });\n}\n","import { forEachAST, } from \"../ast/ast\";\nimport { defaultGraphstate, generateCode, } from \"../codegen/codegen\";\nimport { compilerError, } from \"../compiler-errors\";\nimport { lex } from \"../parse/lex\";\nimport { parse } from \"../parse/parse\";\nimport { addScopesToAST, newScope, } from \"../scope-tree/create-scope-tree\";\nimport { getLinesAndCols } from \"../index\";\nimport { typecheckScopeTree } from \"../scope-tree/typecheck/typecheck\";\nimport { addStdlibToScope } from \"../stdlib/stdlib\";\nimport { resolveFileImports } from \"../scope-tree/resolve-imports\";\nimport { assertNotUndefined } from \"../compiler-errors\";\nimport { instantiateMacros, resolveMacros, } from \"../macro/instantiate-macros\";\nexport function lexAndParse(filename, src, errors, highlights) {\n    const tokens = lex(src, filename, errors);\n    const ast = parse(tokens, filename, errors, highlights);\n    return ast;\n}\nexport function resolveScopes(filename, importer, alreadyVisitedFiles, errors, imports, compilationUnits, io, importScripts) {\n    const fullFilename = io.resolvePath(io.dirname(importer), filename);\n    if (alreadyVisitedFiles.has(fullFilename))\n        return fullFilename;\n    const fileinfo = imports.get(fullFilename);\n    if (!fileinfo) {\n        errors.push(compilerError(\"BAD IMPORT\", 0, 0, filename));\n        return \"\";\n    }\n    alreadyVisitedFiles.add(fullFilename);\n    const getAbsolutePath = (cwdfile, path) => io.resolvePath(io.dirname(cwdfile), path);\n    const scopingContext = {\n        resolveImport: (filename, importer) => resolveScopes(filename, importer, alreadyVisitedFiles, errors, imports, compilationUnits, io, importScripts),\n        unit: fullFilename,\n        errors: errors,\n        importScripts,\n        getAbsolutePath,\n    };\n    const rootScope = newScope(undefined, \"\", scopingContext, 0, fileinfo.src.length);\n    addStdlibToScope(rootScope, scopingContext);\n    const scopedAST = addScopesToAST(fileinfo.ast, {\n        scope: rootScope,\n        isValueBlock: false,\n    }, scopingContext);\n    compilationUnits.set(fullFilename, {\n        scopeTree: scopedAST.enclosingScope,\n        name: fullFilename,\n        src: fileinfo.src,\n        linesAndCols: getLinesAndCols(fileinfo.src),\n        ast: scopedAST,\n    });\n    return fullFilename;\n}\nexport async function handleMacros(compilationUnits, alreadyVisitedFiles, errors, imports, sourceCode, io, watchFiles, importScripts, getAbsolutePath) {\n    // resolve all macros\n    for (let i = 0; i < 100; i++) {\n        let keepOnInstantiating = false;\n        const macroResolvers = [];\n        for (const unit of compilationUnits.values()) {\n            const mctx = {\n                unit: unit.name,\n                units: compilationUnits,\n                resolveImport: (str, importer) => resolveScopes(str, importer, alreadyVisitedFiles, errors, imports, compilationUnits, io, importScripts),\n                sourceCode,\n                errors,\n                io,\n                watchFiles: watchFiles,\n                importScripts,\n                getAbsolutePath,\n            };\n            keepOnInstantiating || (keepOnInstantiating = instantiateMacros(unit.ast, mctx));\n            macroResolvers.push(resolveMacros(unit.ast, mctx));\n        }\n        await Promise.all(macroResolvers);\n        if (!keepOnInstantiating)\n            break;\n        if (i == 100) {\n            // TODO: better error feedback\n            errors.push(compilerError(\"maximum macro instantiation depth exceeded\", 0, 0, \"\"));\n        }\n    }\n}\nexport function createASTLookupTable(ast, astNodes) {\n    forEachAST(ast, undefined, (node, ctx) => {\n        astNodes.set(node.id, node);\n        return undefined;\n    });\n}\nexport function createASTLookupTableSingleCompilationUnit(unit, astNodes) {\n    createASTLookupTable(unit.ast, astNodes);\n}\nexport function createASTLookupTableMultipleCompilationUnits(compilationUnits) {\n    // get a LUT containing every AST node (will be useful later)\n    const astNodes = new Map();\n    for (const unit of compilationUnits.values()) {\n        createASTLookupTableSingleCompilationUnit(unit, astNodes);\n    }\n    return astNodes;\n}\nexport async function compileDesmoscript(entryPoint, settings) {\n    const imports = new Map();\n    const importScripts = new Map();\n    const sourceCode = new Map();\n    const errors = [];\n    const compilationUnits = new Map();\n    const alreadyVisitedFiles = new Set();\n    // lex/parse entry point and import all files\n    await resolveFileImports(entryPoint, entryPoint, undefined, {\n        imports,\n        sourceCode,\n        lexAndParse,\n        errors,\n        getFile: async (filepath) => {\n            if (settings.unsavedFiles.has(filepath)) {\n                const unsavedFile = settings.unsavedFiles.get(filepath);\n                return unsavedFile;\n            }\n            const unsavedFile = await settings.io.readFile(filepath);\n            return unsavedFile;\n        },\n        io: settings.io,\n        watchFiles: settings.watchFiles,\n        importScripts,\n    });\n    if (errors.length > 0)\n        return {\n            type: \"error\",\n            errors,\n            sourceCode,\n        };\n    // create scope trees for everything\n    resolveScopes(entryPoint, entryPoint, alreadyVisitedFiles, errors, imports, compilationUnits, settings.io, importScripts);\n    if (errors.length > 0)\n        return { type: \"error\", errors, sourceCode };\n    const getAbsolutePath = (cwdfile, path) => settings.io.resolvePath(settings.io.dirname(cwdfile), path);\n    await handleMacros(compilationUnits, alreadyVisitedFiles, errors, imports, sourceCode, settings.io, settings.watchFiles, importScripts, getAbsolutePath);\n    const astNodes = createASTLookupTableMultipleCompilationUnits(compilationUnits);\n    // typecheck everything\n    const entryPointFullPath = settings.io.resolvePath(settings.io.dirname(entryPoint), entryPoint);\n    const entryCompilationUnit = assertNotUndefined(compilationUnits.get(entryPointFullPath), `${entryPointFullPath} not found in compileDesmoscript`);\n    const typeErrors1 = typecheckScopeTree(entryCompilationUnit.scopeTree, {\n        units: compilationUnits,\n        unitName: entryPointFullPath,\n        astNodes,\n        dependencyChain: new Map(),\n        knownTypes: new Map(),\n        knownCircularDependencies: new Set(),\n    }) ?? { why: [] };\n    errors.push(...typeErrors1.why);\n    // generate code\n    const codegenErrors = [];\n    const state = defaultGraphstate();\n    const generatedCode = generateCode({\n        units: compilationUnits,\n        currentUnit: settings.io.resolvePath(entryPoint),\n        identifierNames: new Map(),\n        existingNames: new Set(),\n        astNodes,\n        state,\n        alreadyCompiledUnits: new Set(),\n        alreadyGeneratedBlockFinalExpressionIDs: new Set(),\n        errors: codegenErrors,\n        options: settings.options,\n    });\n    return {\n        type: \"success\",\n        errors: [...errors, ...codegenErrors],\n        state,\n        sourceCode,\n    };\n}\n","import { assertNotUndefined, } from \"../compiler-errors\";\nimport { lex, parse, typecheckScopeTree } from \"../index\";\nimport { resolveFileImports } from \"../scope-tree/resolve-imports\";\nimport { createASTLookupTableMultipleCompilationUnits, handleMacros, lexAndParse, resolveScopes, } from \"./full-compiler\";\nimport { formatError } from \"../scope-tree/typecheck/type-errors\";\nimport { forEachAST } from \"../ast/ast\";\nimport { findIdentifierScopeItem } from \"../scope-tree/create-scope-tree\";\nimport { formatAST } from \"../ast/fmt\";\nimport { compareAST } from \"../ast/compare-ast\";\nimport { debugPrint } from \"../debug/debug\";\nfunction findSmallestEnclosingScope(scope, position) {\n    for (const [itemName, item] of scope.elements) {\n        if (item.type == \"scope\" &&\n            position >= item.start &&\n            position <= item.end) {\n            return findSmallestEnclosingScope(item.scope, position);\n        }\n    }\n    return scope;\n}\n// i'll probably have chokidar support later so that changes from\n// other sources can be properly picked up\nexport function compileDesmoscriptForLanguageSupport(io) {\n    const unsavedFiles = new Map();\n    const watchFiles = new Set();\n    let activeWatchers = [];\n    const getAbsolutePath = (cwdfile, path) => io.resolvePath(io.dirname(cwdfile), path);\n    async function recompile(entryPoint) {\n        if (cachedRecompilation)\n            return cachedRecompilation;\n        const imports = new Map();\n        const importScripts = new Map();\n        const sourceCode = new Map();\n        const errors = [];\n        const compilationUnits = new Map();\n        const alreadyVisitedFiles = new Set();\n        const highlightsMap = new Map();\n        // lex/parse entry point and import all files\n        await resolveFileImports(entryPoint, entryPoint, undefined, {\n            imports,\n            sourceCode,\n            lexAndParse,\n            errors,\n            getFile: async (filepath) => {\n                if (unsavedFiles.has(filepath))\n                    return unsavedFiles.get(filepath);\n                return await io.readFile(filepath);\n            },\n            highlightsMap,\n            io,\n            watchFiles,\n            importScripts,\n        });\n        // create scope trees for everything\n        resolveScopes(entryPoint, entryPoint, alreadyVisitedFiles, errors, imports, compilationUnits, io, importScripts);\n        await handleMacros(compilationUnits, alreadyVisitedFiles, errors, imports, sourceCode, io, watchFiles, importScripts, getAbsolutePath);\n        for (const closeWatcher of activeWatchers) {\n            closeWatcher();\n        }\n        activeWatchers = [];\n        watchFiles.forEach((filename) => {\n            activeWatchers.push(io.watchFile(filename, () => {\n                cachedRecompilation = undefined;\n            }));\n        });\n        const astNodes = createASTLookupTableMultipleCompilationUnits(compilationUnits);\n        // typecheck everything\n        const entryPointFullPath = io.resolvePath(entryPoint);\n        const entryCompilationUnit = assertNotUndefined(compilationUnits.get(entryPointFullPath), `${entryPointFullPath} not found in compileDesmoscriptForLanguageSupport (available are ${JSON.stringify(Array.from(compilationUnits.keys()))}) (sourcecode: ${JSON.stringify(Array.from(sourceCode.keys()))})`);\n        /*console.log(\n          \"COMPILATIONUNITS\",\n          compilationUnits,\n          Array.from(compilationUnits.keys()),\n          Array.from(sourceCode.keys())\n        );*/\n        errors.push(...(typecheckScopeTree(entryCompilationUnit.scopeTree, {\n            units: compilationUnits,\n            unitName: entryPointFullPath,\n            astNodes,\n            dependencyChain: new Map(),\n            knownTypes: new Map(),\n            knownCircularDependencies: new Set(),\n        })?.why ?? []));\n        cachedRecompilation = {\n            errors,\n            compilationUnits,\n            sourceCode,\n            highlightsMap,\n        };\n        return cachedRecompilation /*{\n            errors: [],\n            compilationUnits: new Map(),\n            sourceCode: new Map(),\n            highlightsMap: new Map(),\n        }*/;\n    }\n    let cachedRecompilation;\n    return {\n        updateFile(filename, src) {\n            cachedRecompilation = undefined;\n            unsavedFiles.set(io.resolvePath(filename), src);\n        },\n        async highlightSyntax(filename, handler2) {\n            filename = io.resolvePath(filename);\n            const ctx = await recompile(filename);\n            console.log(ctx);\n            const code = ctx.sourceCode.get(filename);\n            if (!code)\n                return;\n            const handler = (str, start, end, type) => {\n                if (start == end)\n                    return;\n                const splitStr = str.split(\"\\n\");\n                for (const substr of splitStr) {\n                    let end = start + substr.length;\n                    handler2(substr, start, end, type);\n                    start = end + 1;\n                }\n            };\n            if (!ctx.highlightsMap)\n                return;\n            const highlights = ctx.highlightsMap.get(filename);\n            if (highlights) {\n                for (const hl of highlights) {\n                    handler2(code.src.slice(hl.start, hl.end), hl.start, hl.end, hl.type);\n                }\n            }\n            if (!ctx.compilationUnits)\n                return;\n            const unit = ctx.compilationUnits.get(filename);\n            if (!unit)\n                return;\n            forEachAST(unit.ast, undefined, (node) => {\n                if (!ctx.compilationUnits)\n                    return;\n                if (node.type == \"identifier\") {\n                    const def = findIdentifierScopeItem(unit, node.enclosingScope, node.segments, { compilationUnits: ctx.compilationUnits });\n                    if (def.result != \"found\")\n                        return;\n                    handler(node.segments[node.segments.length - 1], node.start +\n                        node.segments.slice(0, -1).join(\".\").length +\n                        (node.segments.length > 1 ? 1 : 0), node.end, {\n                        variable: \"variable\",\n                        function: \"function\",\n                        scope: \"namespace\",\n                        \"builtin-variable\": \"variable\",\n                        \"builtin-function\": \"function\",\n                        note: \"string\",\n                        macro: \"macro\",\n                        expression: \"variable\",\n                        import: \"namespace\",\n                        settings: \"variable\",\n                    }[def.identifier.type]);\n                    return;\n                }\n            });\n        },\n        async getDefinitions(filename, handler) {\n            filename = io.resolvePath(filename);\n            const ctx = await recompile(filename);\n            if (!ctx.compilationUnits)\n                return;\n            const unit = ctx.compilationUnits.get(filename);\n            if (!unit)\n                return;\n            forEachAST(unit.ast, undefined, (node) => {\n                if (!ctx.compilationUnits)\n                    return;\n                if (node.type == \"identifier\") {\n                    const def = findIdentifierScopeItem(unit, node.enclosingScope, node.segments, { compilationUnits: ctx.compilationUnits });\n                    if (def.result != \"found\")\n                        return;\n                    if (def.identifier.type != \"function\" &&\n                        def.identifier.type != \"variable\")\n                        return;\n                    handler(node.segments.join(\".\"), node.start, node.end, def.identifier.start, def.identifier.end, def.identifier.unitName);\n                }\n                return;\n            });\n        },\n        async goToDefinition(filename, position) {\n            filename = io.resolvePath(filename);\n            const ctx = await recompile(filename);\n            if (!ctx.compilationUnits)\n                return;\n            const unit = ctx.compilationUnits.get(filename);\n            if (!unit)\n                return;\n            let clickedOnNode;\n            forEachAST(unit.ast, undefined, (node) => {\n                if (!ctx.compilationUnits)\n                    return;\n                if (node.type == \"identifier\" &&\n                    position >= node.start &&\n                    position <= node.end)\n                    clickedOnNode = node;\n            });\n            if (!clickedOnNode)\n                return;\n            const def = findIdentifierScopeItem(unit, clickedOnNode.enclosingScope, clickedOnNode.segments, { compilationUnits: ctx.compilationUnits });\n            if (def.result != \"found\")\n                return;\n            if (def.identifier.type != \"function\" &&\n                def.identifier.type != \"variable\")\n                return;\n            return {\n                start: def.identifier.start,\n                end: def.identifier.end,\n                unit: def.identifier.unitName,\n            };\n        },\n        async getErrors(filename, handler) {\n            filename = io.resolvePath(filename);\n            const ctx = await recompile(filename);\n            for (const err of ctx.errors) {\n                if (err.unit == filename) {\n                    handler(err.start, err.end, formatError({\n                        format: (str, opts) => str,\n                        entry: filename,\n                        sourceCode: ctx.sourceCode,\n                        maxWidth: 80,\n                        hideSourceCode: true,\n                        io,\n                    }, err));\n                    if (err.type == \"circular-dependency\") {\n                        for (const patherr of err.path) {\n                            handler(patherr.start, patherr.end, \"this is part of a circular dependency chain\");\n                        }\n                    }\n                }\n            }\n        },\n        async formatFile(filename) {\n            filename = io.resolvePath(filename);\n            const ctx = await recompile(filename);\n            if (!ctx.compilationUnits)\n                return;\n            const unit = ctx.compilationUnits.get(filename);\n            if (!unit)\n                return undefined;\n            const fmtted = formatAST(unit.ast);\n            const flexed = lex(fmtted, unit.name, []);\n            const fast = parse(flexed, unit.name, []);\n            // make sure formatter is implemented properly\n            // if formatted AST doesn't match wtih non formatted AST, then\n            // don't accept the result\n            const astComparison = compareAST(unit.ast, fast);\n            if (astComparison.length > 0) {\n                debugPrint(\"AST DIFFERENCE IN FORMATTER: \", astComparison);\n                return;\n            }\n            return fmtted;\n        },\n        async getColors(filename, handler) {\n            filename = io.resolvePath(filename);\n            const ctx = await recompile(filename);\n            if (!ctx.compilationUnits)\n                return;\n            const unit = ctx.compilationUnits.get(filename);\n            if (!unit)\n                return undefined;\n            const ast = unit.ast;\n            forEachAST(ast, undefined, (node) => {\n                if (node.type == \"fncall\" &&\n                    node.name.segments[0] == \"rgb\" &&\n                    node.params[0]?.type == \"number\" &&\n                    node.params[1]?.type == \"number\" &&\n                    node.params[2]?.type == \"number\") {\n                    handler(node.start, node.end, [\n                        node.params[0].number,\n                        node.params[1].number,\n                        node.params[2].number,\n                    ]);\n                }\n            });\n        },\n        async getAutocomplete(filename, position, handler) {\n            filename = io.resolvePath(filename);\n            const ctx = await recompile(filename);\n            if (!ctx.compilationUnits)\n                return;\n            const unit = ctx.compilationUnits.get(filename);\n            if (!unit)\n                return undefined;\n            const searchScope = findSmallestEnclosingScope(unit.scopeTree, position);\n            let searchString = \"\";\n            let pos = position - 1;\n            while (unit.src[pos] && unit.src[pos].match(/[a-zA-Z_0-9\\.]/g)) {\n                searchString = unit.src[pos] + searchString;\n                pos--;\n            }\n            pos = position;\n            while (unit.src[pos] && unit.src[pos].match(/[a-zA-Z_0-9\\.]/g)) {\n                searchString += unit.src[pos];\n                pos++;\n            }\n            const segments = searchString.split(\".\");\n            const pathToFinalScope = segments.slice(0, -1);\n            const lastSegment = segments[segments.length - 1];\n            let innerScope;\n            if (pathToFinalScope.length != 0) {\n                const scopeItem = findIdentifierScopeItem(unit, searchScope, pathToFinalScope, { compilationUnits: ctx.compilationUnits });\n                if (scopeItem.result != \"found\")\n                    return;\n                if (scopeItem.identifier.type != \"scope\")\n                    return;\n                innerScope = scopeItem.identifier.scope;\n            }\n            else {\n                innerScope = searchScope;\n            }\n            for (const [itemName, item] of innerScope.elements) {\n                if (itemName.startsWith(lastSegment)) {\n                    const suggestion = itemName;\n                    let completionType = \"variable\";\n                    switch (item.type) {\n                        case \"function\":\n                        case \"builtin-function\":\n                            completionType = \"function\";\n                        case \"macro\":\n                            completionType = \"macro\";\n                        case \"scope\":\n                            completionType = \"scope\";\n                    }\n                    handler(suggestion, completionType);\n                }\n            }\n        },\n        async onHover(filename, position) {\n            filename = io.resolvePath(filename);\n            const ctx = await recompile(filename);\n            if (!ctx.compilationUnits)\n                return;\n            const unit = ctx.compilationUnits.get(filename);\n            if (!unit)\n                return undefined;\n            let hoverASTNode;\n            forEachAST(unit.ast, undefined, (node) => {\n                if (position >= node.start && position <= node.end) {\n                    if (node.type == \"macrocall\") {\n                        hoverASTNode = node;\n                    }\n                }\n            });\n            if (!hoverASTNode)\n                return;\n            if (hoverASTNode.type == \"macrocall\" &&\n                hoverASTNode.result &&\n                !(hoverASTNode.result instanceof Promise)) {\n                return `Evaluates to:\\n${formatAST(hoverASTNode.result)}`;\n            }\n        },\n    };\n}\n","export function compareAST(a, b) {\n    // returns ASTDifferences if inputs are ASTNodes\n    // returns boolean if inputs are primitives (true=same, false=diff)\n    function c(a, b) {\n        if (a === undefined)\n            return a === b;\n        if (typeof a != typeof b)\n            return false;\n        if (typeof a == \"number\" || typeof a == \"string\" || typeof a == \"boolean\")\n            return a == b;\n        if (Array.isArray(a)) {\n            if (!Array.isArray(b))\n                return false;\n            if (a.length != b.length)\n                return false;\n            let diffs = [];\n            for (let i = 0; i < a.length; i++) {\n                const result = c(a[i], b[i]);\n                if (result === false)\n                    return false;\n                if (Array.isArray(result))\n                    diffs.push(...result);\n            }\n            return diffs;\n        }\n        if (typeof a == \"object\" && typeof a.id == \"number\") {\n            let diffs = [];\n            const anode = a;\n            if (typeof b != \"object\" || typeof b.id != \"number\")\n                return [{ nodeA: anode }];\n            const bnode = b;\n            for (const k of Object.keys(a)) {\n                if (k == \"id\")\n                    continue;\n                if (k == \"start\")\n                    continue;\n                if (k == \"end\")\n                    continue;\n                if (k == \"enclosingScope\")\n                    continue;\n                if (k == \"innerScope\")\n                    continue;\n                if (k == \"result\" && anode.type == \"macrocall\")\n                    continue;\n                const result = c(a[k], b[k]);\n                if (result === false)\n                    return [{ nodeA: anode, nodeB: bnode }];\n                if (Array.isArray(result))\n                    diffs.push(...result);\n            }\n            return diffs;\n        }\n        return false;\n    }\n    return c(a, b);\n}\n","export let placeholder = 0;\nexport function getLinesAndCols(str) {\n    const linesAndCols = [];\n    let line = 1;\n    let col = 1;\n    for (const char of str) {\n        linesAndCols.push([line, col]);\n        if (char == \"\\n\") {\n            line++;\n            col = 1;\n        }\n        else {\n            col++;\n        }\n    }\n    return linesAndCols;\n}\nexport { lex } from \"./parse/lex\";\nexport { parse } from \"./parse/parse\";\nexport { typecheckScopeTree } from \"./scope-tree/typecheck/typecheck\";\nexport { compileDesmoscript } from \"./combined-functionality/full-compiler\";\nexport { compileDesmoscriptForLanguageSupport } from \"./combined-functionality/language-support-compiler\";\nexport { enableDebug } from \"./debug/debug\";\nexport { formatError } from \"./scope-tree/typecheck/type-errors\";\n"],"names":["__webpack_require__","exports","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","value","DESMO_DEBUG","enableDebug","debugPrint","_console","console","log","apply","arguments","debugTrace","trace","compilerError","reason","start","end","unit","type","internalError","internal","assertNotUndefined","t","customErrorMessage","undefined","lex","input","filename","errors","str","pos","stream","done","length","match","pattern","noConsume","Array","isArray","_step","_iterator","_createForOfIteratorHelper","s","n","p","slice","startsWith","err","e","f","RegExp","_str$slice$match","Function","count","next","x","rest","tokens","appendMatch","push","token","linebreaks","note","symbol","bracket","num","op","ident","offendingText","concat","_regeneratorRuntime","Op","hasOwn","desc","$Symbol","iteratorSymbol","iterator","asyncIteratorSymbol","asyncIterator","toStringTagSymbol","define","configurable","writable","wrap","innerFn","outerFn","self","tryLocsList","protoGenerator","Generator","generator","create","context","Context","makeInvokeMethod","tryCatch","fn","arg","ContinueSentinel","GeneratorFunction","GeneratorFunctionPrototype","IteratorPrototype","getProto","getPrototypeOf","NativeIteratorPrototype","values","Gp","defineIteratorMethods","forEach","method","_invoke","AsyncIterator","PromiseImpl","invoke","resolve","reject","record","result","_typeof","__await","then","unwrapped","error","previousPromise","callInvokeWithMethodAndArg","state","Error","delegate","delegateResult","maybeInvokeDelegate","sent","_sent","dispatchException","abrupt","methodName","TypeError","info","resultName","nextLoc","pushTryEntry","locs","entry","tryLoc","catchLoc","finallyLoc","afterLoc","tryEntries","resetTryEntry","completion","reset","iterable","iteratorMethod","isNaN","i","doneResult","displayName","isGeneratorFunction","genFun","ctor","constructor","name","mark","setPrototypeOf","__proto__","awrap","async","Promise","iter","keys","val","object","reverse","pop","skipTempReset","prev","charAt","stop","rootRecord","rval","exception","handle","loc","caught","hasCatch","hasFinally","finallyEntry","complete","finish","thrown","delegateYield","asyncGeneratorStep","gen","_next","_throw","_asyncToGenerator","args","_slicedToArray","arr","_arrayWithHoles","_i","_s","_e","_x","_r","_arr","_n","_d","_iterableToArrayLimit","minLen","_arrayLikeToArray","toString","from","test","_unsupportedIterableToArray","_nonIterableRest","len","arr2","errnode","idCounter","newid","asExpr","node","success","data","getErrors","ast","map","flat","forEachAST","ctx","mapper","myctx","id","innerctx","entries","_ref","_ref2","forEachASTAsync","_x2","_x3","_x4","_forEachASTAsync","_callee2","_map","_context2","_callee","_node2","_context","all","_ref3","_ref4","v","_x5","_x6","parse","unitName","highlights","tokenStream","considerWhitespace","peek","pos2","prevPeek","stringpos","_tokens$pos$start","_tokens$pos","stringposend","offset","_tokens$end","_tokens2","remainingOffset","Math","abs","offsetSign","sign","posOffset","_tokens","getpos","setpos","tokenStreamify","encounteredTokenErrors","Set","nodefn","restartOnFailure","oldpos","rawNode","expectToken","endOfInputErr","expectOneOfTheseTokens","strs","join","expectTokenType","_ref5","expectExpression","bindingPower","parseExpr","expectJson","isTopLevel","parseJson","isNextToken","isNextTokenType","consumeTokenIfExists","expectExpressionOrStatement","parseStatement","expectAny","message","tokenError","has","add","_objectSpread","maybeNext","maybePeek","isEnd","markNoReturn","highlightLastToken","highlight","lastToken","softError","clearErrorsFrom","splice","parseBlock","parseMatch","a","lhs","branches","rhs","fallback","isRoot","body","last","parseNumber","number","Number","parseIdentifier","segments","first","parseNote","content","bindingPowers","rightAssociative","getBindingPowerStr","_bindingPowers$str","getBindingPower","_bindingPowers$token$","parseConsequentExpr","leftNode","_rightAssociative$tok","parseBinaryOp","currentBindingPower","initToken","params","parseFunctionCall","node2","parseMacroCall","operand","parseUnaryOp","elements","typeAnnotation","initExpr","initElem","secondElement","step","parseListOrRange","left","right","parseListcomp","parseListOrListcomp","y","parseParenthesizedOrPoint","parseInitExpr","nextToken","consequentExpr","src","alias","parseImport","parseFunctionDef","settings","parseNamespace","parseShow","settingsType","parseSettings","parseAssignment","topLevel","expr","indent","padStart","maxLineLength","split","reduce","curr","max","formatAST","c","tabSize","maxlen","ctxwith","patch","splitByLine","dontIndentFirst","l","r","rootOffset","fnname","fnparams","fndefparams","nextIndent","d","k","annotation","_ref6","_toConsumableArray","filter","newScope","parent","isWithinFunction","scope","Map","imports","importScripts","addToScope","existing","namespaceCollision","startB","endB","unitB","set","addScopesToAST","_state$parentNode4","_state$parentNode5","_state$parentNode6","child","innerScope","isValueBlock","parentNode","getDisplay","_state$parentNode","display","enclosingScope","_step2","_iterator2","_step2$value","_state$parentNode2","_state$parentNode3","text","resolvedImport","resolveImport","compilationUnitPath","resolvedImport2","getAbsolutePath","iscript","run","fromEntries","mapASTToAddScopes","getScopeNameList","path","findIdentifierScopeItem","compilationUnit","initSearchScope","identifierSegments","compilationContext","previouslySearchedUnits","scopePath","currentScope","_i3","_scopePath","identifierScope","segment","possibleNextIdentifierScope","identifier","memberAccess","compilationUnits","scopeTree","_step5","_iterator5","otherFile","searchResult","formatCircularDependencyError","units","dependencyChain","offendingScopeItem","knownCircularDependencies","_offendingScopeItem$s","_offendingScopeItem$e","_v$node$start","_v$node$end","_step$value","nodeUnit","errorType","notFoundError","wrongTypeError","why","formatScopeItemTypeName","typename","replace","indentation","padEnd","formatCodeFragment","sourceCode","_unit$linesAndCols$er","linesAndCols","lastNewline","remaining","lastNewlinePos","nextNewline","nextNewlinePos","gutterLineNo","gutterPad","floor","log10","format","formatError","_err$start","_ctx$sourceCodeErrorC","maxWidth","line","col","baseErr","io","relativePath","_line$match$0$length","_line$match","lines","splitInput","hideSourceCode","sourceCodeErrorContext","unitData","_ctx$sourceCodeErrorC2","_ref8","typecheckElementwise","b","handler","primitiveTest","element","consolidateTypeErrors","ownKeys","enumerableOnly","getOwnPropertySymbols","symbols","sym","getOwnPropertyDescriptor","target","source","_defineProperty","getOwnPropertyDescriptors","defineProperties","hint","prim","toPrimitive","res","String","_toPrimitive","_toPropertyKey","macroError","mapASTChildren","allowArrayLike","it","F","_e2","normalCompletion","didErr","_e3","_arrayWithoutHoles","_iterableToArray","_nonIterableSpread","desmosVariables","util","variadicOf","ret","returns","validTypes","nNumbers","fill","listof","statisticalFunctionWithDistribution","primitives","numberOrNumberList","desmosFunctions","requiredCount","minArgs","isCompatible","dst","typeAsStr","getASTNode","requiredType","astNodes","getASTExpr","asexpr","addVarsToCtx","vars","newVars","knownTypes","getInnerDefinedVariable","typecheckFnCall","fndefFindResult","_step4","fndefScopeContent","paramTypes","_iterator4","typecheckExpr","fndefStmt","paramID","def","typeSignature","_loop","_overload$minArgs","overload","_overload$requiredCou","every","_ret","ol","param","vt","printOverload","typecheckBuiltinFn","typecheckCompare","typecheckLogicOperator","typecheckListSubscript","typecheckBinop","lastNode","maybeLastExpr","typecheckBlock","identifierScopeItem","identifierBodyExpr","typecheckIdentifier","elemTypes","elemType","_step3","_iterator3","elem","thisElemType","typecheckList","pname","ptype","varScopeContent","typecheckListcomp","resultErrors","errs","badMacroError","maybeResultExpr","typecheckMacrocall","_branchTypes$0$","_branchTypes$","branchTypes","fallbackType","testBranch","branch","branchType","_step5$value","condExpr","branchExpr","condType","typecheckMatch","lhsType","rhsType","stepType","_step6","_iterator6","_step6$value","typecheckRange","operandType","indexOf","typecheckUnop","typecheckPoint","typecheckScopeTree","types","_step7","_iterator7","_step7$value","item","assertEqual","assertIs","_arg","assertNever","arrayToEnum","items","getValidEnumValues","validKeys","objectKeys","filtered","objectValues","find","checker","isInteger","isFinite","joinValues","array","separator","jsonStringifyReplacer","_","ZodParsedType","getParsedType","string","nan","boolean","function","bigint","null","catch","promise","Date","date","unknown","ZodIssueCode","ZodError","issues","super","this","addIssue","sub","addIssues","subs","actualProto","_mapper","issue","fieldErrors","_errors","processError","code","unionErrors","returnTypeError","argumentsError","el","JSON","stringify","isEmpty","flatten","formErrors","errorMap","_ctx","invalid_type","received","expected","invalid_literal","unrecognized_keys","invalid_union","invalid_union_discriminator","options","invalid_enum_value","invalid_arguments","invalid_return_type","invalid_date","invalid_string","validation","endsWith","too_small","exact","inclusive","minimum","too_big","maximum","custom","invalid_intersection_types","not_multiple_of","multipleOf","not_finite","defaultError","overrideErrorMap","getErrorMap","makeIssue","errorMaps","issueData","fullPath","fullIssue","errorMessage","maps","m","addIssueToContext","common","contextualErrorMap","schemaErrorMap","ParseStatus","dirty","abort","static","status","results","arrayValue","INVALID","pairs","syncPairs","pair","mergeObjectSync","finalObject","alwaysSet","freeze","DIRTY","OK","isAborted","isDirty","isValid","isAsync","errorUtil","errToObj","ParseInputLazyPath","_path","_key","handleResult","processCreateParams","invalid_type_error","required_error","description","iss","ZodType","spa","safeParseAsync","_def","bind","safeParse","parseAsync","refine","refinement","superRefine","optional","nullable","nullish","or","and","transform","brand","default","describe","pipe","isNullable","isOptional","_getType","_getOrReturnCtx","parsedType","_processInputParams","_parseSync","_parse","_parseAsync","_a","maybeAsyncResult","check","getIssueProperties","_refinement","setError","refinementData","ZodEffects","schema","typeName","ZodFirstPartyTypeKind","effect","ZodOptional","ZodNullable","ZodArray","ZodPromise","option","ZodUnion","incoming","ZodIntersection","ZodDefault","innerType","defaultValue","ZodBranded","ZodCatch","This","ZodPipeline","cuidRegex","uuidRegex","emailRegex","ZodString","_regex","regex","nonempty","min","trim","checks","kind","coerce","tooBig","tooSmall","URL","lastIndex","precision","_addCheck","email","url","uuid","cuid","datetime","minLength","maxLength","isDatetime","ch","isEmail","isURL","isUUID","isCUID","floatSafeRemainder","valDecCount","stepDecCount","decCount","parseInt","toFixed","pow","ZodNumber","gte","lte","setLimit","gt","lt","int","positive","negative","nonpositive","nonnegative","finite","minValue","maxValue","isInt","ZodBigInt","BigInt","ZodBoolean","Boolean","ZodDate","getTime","minDate","maxDate","ZodSymbol","ZodUndefined","ZodNull","ZodAny","_any","ZodUnknown","_unknown","ZodNever","never","ZodVoid","void","exactLength","mergeArray","objectUtil","mergeShapes","second","AugmentFactory","augmentation","ZodObject","shape","deepPartialify","newShape","fieldSchema","unwrap","ZodTuple","_cached","nonstrict","passthrough","augment","extend","_getCached","shapeKeys","extraKeys","catchall","unknownKeys","includes","keyValidator","strict","_b","_c","strip","setKey","merge","merging","index","pick","mask","omit","deepPartial","partial","required","newField","keyof","createZodEnum","strictCreate","lazycreate","childCtx","getDiscriminator","ZodLazy","ZodLiteral","ZodEnum","ZodNativeEnum","enum","ZodDiscriminatedUnion","discriminator","discriminatorValue","optionsMap","discriminatorValues","mergeValues","aType","bType","valid","bKeys","sharedKeys","newObj","sharedValue","newArray","handleParsed","parsedLeft","parsedRight","merged","itemIndex","schemas","ZodRecord","keySchema","keyType","valueSchema","valueType","mergeObjectAsync","third","ZodMap","finalMap","ZodSet","minSize","size","maxSize","finalizeSet","parsedSet","ZodFunction","validate","implement","makeArgsIssue","makeReturnsIssue","parsedArgs","parsedReturns","parameters","returnType","func","strictImplement","getter","expectedValues","enumValues","Values","Enum","nativeEnumValues","promisified","sourceType","processed","checkCtx","fatal","executeRefinement","acc","inner","base","createWithPreprocess","preprocess","removeDefault","ZodNaN","BRAND","inResult","in","out","handleAsync","p2","late","stringType","numberType","nanType","bigIntType","booleanType","dateType","symbolType","undefinedType","nullType","anyType","unknownType","neverType","voidType","arrayType","objectType","strictObjectType","unionType","discriminatedUnionType","intersectionType","tupleType","recordType","mapType","setType","functionType","lazyType","literalType","enumType","nativeEnumType","promiseType","effectsType","optionalType","nullableType","preprocessType","pipelineType","NEVER","mod","defaultErrorMap","setErrorMap","EMPTY_PATH","ZodTransformer","Schema","ZodSchema","any","discriminatedUnion","cls","intersection","lazy","literal","nativeEnum","oboolean","onumber","ostring","pipeline","strictObject","transformer","tuple","union","quotelessJson","baseItemStateParser","z","secret","baseNonFolderStateParser","folderId","lineStyleParser","pointStyleParser","dragModeParser","labelSizeParser","labelOrientationParser","domainParser","baseClickableParser","enabled","latex","expressionStateWithoutColumnParser","showLabel","fillOpacity","label","labelSize","labelOrientation","labelAngle","suppressTextOutline","interactiveLabel","editableLabelMode","residualVariable","regressionParameters","isLogModeRegression","displayEvaluationAsFraction","slider","hardMin","hardMax","animationPeriod","loopMode","playDirection","isPlaying","polarDomain","parametricDomain","domain","cdf","show","vizProps","breadth","axisOffset","alignedAxis","showBoxplotOutliers","dotplotXMode","binAlignment","histogramMode","clickableInfo","columnExpressionSharedParser","color","hidden","points","dragMode","lineStyle","pointStyle","colorLatex","lineOpacity","lineWidth","pointSize","pointOpacity","expressionStateParser","imageStateParser","image_url","width","height","center","angle","opacity","foreground","draggable","hoveredImage","depressedImage","tableColumnParser","tableStateParser","columns","folderStateParser","collapsed","title","textStateParser","arrowModeParser","GrapherStateParser","viewport","xmin","ymin","xmax","ymax","xAxisMinorSubdivisions","yAxisMinorSubdivisions","degreeMode","showGrid","showXAxis","showYAxis","xAxisNumbers","yAxisNumbers","polarNumbers","xAxisStep","yAxisStep","xAxisArrowMode","yAxisArrowMode","xAxisLabel","yAxisLabel","squareAxes","restrictGridToFirstQuadrant","polarMode","userLockedViewport","nonFolderStateParser","tickerParser","handlerLatex","minStepLatex","open","playing","itemStateParser","desmosifyName","getNameForIdentifier","identifierPath","startScope","scopeItem","currentUnit","scopeNamePath","definedByDesmos","identifierNames","proposedName","addProposedName","existingNames","identPathElem","toUpperCase","proposedNameWithoutNumber","generateExprCode","alreadyGeneratedBlockFinalExpressionIDs","resultExpr","cond","compileJSON","getJsonNode","generateCodeForScopeTree","allInOneFolderID","folderState","maybeGetDisplay","nodeId","parsedItemState","addDesmoscriptEquivalent","_ctx$folderState","annotateExpressionsWithEquivalentDesmoscript","expressions","list","generateCodeForCompilationUnit","_ctx$folderState2","_ctx$folderState3","_oldFolderState$name","_ctx$folderState4","_ctx$folderState5","_step3$value","itemName","assignment","astNode","oldFolderState","newFolderState","json","parsedSettings","graph","parsedTickerSettings","ticker","alreadyCompiledUnits","resolveFileImports","_resolveFileImports","importer","fullpath","_ctx$highlightsMap","_expr$start","_expr$end","resolvePath","dirname","getFile","watchFiles","getLinesAndCols","lexAndParse","highlightsMap","iscriptFullPath","iscriptSrc","importScript","t0","instantiateMacros","instantiationErrors","instantiated","scopedNode","macroOperation","_readStringFile","parseStmt","macroSrcName","getAbsolutePathRelativeToThisFile","block","fatalError","recoverableError","fmt","readFile","abspath","readStringFile","filepath","getMacroAPI","resolveMacros","_resolveMacros","resolveScopes","alreadyVisitedFiles","fullFilename","fileinfo","scopingContext","cwdfile","rootScope","_macroOperation","_macroOperation2","_macroOperation3","_macroOperation4","param1","contents","_callee3","nsnameNode","iterationsNode","nsname","iterations","processLoopBody","copyNode","getIterName","_context3","itername","cb","round","_callee5","argmap","_context5","_macroOperation5","_callee4","process","_context4","argIndex","_x9","_x10","_x7","_x8","addStdlibToScope","scopedAST","handleMacros","_handleMacros","keepOnInstantiating","macroResolvers","mctx","createASTLookupTableSingleCompilationUnit","createASTLookupTable","createASTLookupTableMultipleCompilationUnits","compileDesmoscript","_x11","_compileDesmoscript","entryPoint","_typecheckScopeTree","entryPointFullPath","entryCompilationUnit","typeErrors1","codegenErrors","_getFile","_unsavedFile","unsavedFile","unsavedFiles","_x12","version","findSmallestEnclosingScope","position","compileDesmoscriptForLanguageSupport","cachedRecompilation","activeWatchers","recompile","_recompile","_callee10","_typecheckScopeTree$w","_context10","_callee9","_context9","closeWatcher","watchFile","updateFile","highlightSyntax","handler2","hl","substr","variable","macro","expression","import","getDefinitions","goToDefinition","clickedOnNode","patherr","opts","formatFile","fmtted","flexed","fast","astComparison","diffs","anode","nodeA","bnode","_Object$keys","nodeB","getColors","_callee6","_context6","_node$params$","_node$params$2","_node$params$3","getAutocomplete","_callee7","searchScope","searchString","pathToFinalScope","lastSegment","suggestion","completionType","_context7","onHover","_callee8","hoverASTNode","_context8","randomSeed","placeholder","char"],"sourceRoot":""}