import { ast } from "./ast.mjs";
type LutFn<NodeType, ReturnType, Ctx> = (node: NodeType, ctx: Ctx) => [ReturnType, Ctx];
type ASTLookupTable<A extends ast.URIS, B extends ast.URIS, C extends ast.URIS, D extends ast.URIS, Ctx> = {
    number: LutFn<ast.Number<A, B>, ast.Number<C, D>, Ctx>;
    binop: LutFn<ast.Binop<A, B>, ast.Binop<C, D>, Ctx>;
    unop: LutFn<ast.Unop<A, B>, ast.Unop<C, D>, Ctx>;
    ident: LutFn<ast.Ident<A>, ast.Ident<C>, Ctx>;
    fncall: LutFn<ast.FnCall<A, B>, ast.FnCall<C, D>, Ctx>;
    macrocall: LutFn<ast.MacroCall<A, B>, ast.MacroCall<C, D>, Ctx>;
    block: LutFn<ast.Block<A, B>, ast.Block<C, D>, Ctx>;
    listcomp: LutFn<ast.Listcomp<A, B>, ast.Listcomp<C, D>, Ctx>;
    point: LutFn<ast.Point<A, B>, ast.Point<C, D>, Ctx>;
    steprange: LutFn<ast.StepRange<A, B>, ast.StepRange<C, D>, Ctx>;
    list: LutFn<ast.List<A, B>, ast.List<C, D>, Ctx>;
    sumprodint: LutFn<ast.SumProdInt<A, B>, ast.SumProdInt<C, D>, Ctx>;
    derivative: LutFn<ast.Derivative<A, B>, ast.Derivative<C, D>, Ctx>;
    case: LutFn<ast.Case<A, B>, ast.Case<C, D>, Ctx>;
    actions: LutFn<ast.Actions<A, B>, ast.Actions<C, D>, Ctx>;
    memberaccess: LutFn<ast.MemberAccess<A, B>, ast.MemberAccess<C, D>, Ctx>;
    dnumber: LutFn<ast.djson.Number<A>, ast.djson.Number<C>, Ctx>;
    dstring: LutFn<ast.djson.String<A>, ast.djson.String<C>, Ctx>;
    dboolean: LutFn<ast.djson.Boolean<A>, ast.djson.Boolean<C>, Ctx>;
    dnull: LutFn<ast.djson.Null<A>, ast.djson.Null<C>, Ctx>;
    darray: LutFn<ast.djson.Array<A, B>, ast.djson.Array<C, D>, Ctx>;
    dobject: LutFn<ast.djson.Object<A, B>, ast.djson.Object<C, D>, Ctx>;
    ddesmoscript: LutFn<ast.djson.Desmoscript<A, B>, ast.djson.Desmoscript<C>, Ctx>;
    assignment: LutFn<ast.Assignment<A, B>, ast.Assignment<C, D>, Ctx>;
    namespace: LutFn<ast.Namespace<A, B>, ast.Namespace<C, D>, Ctx>;
    namedjson: LutFn<ast.NamedJSON<A, B>, ast.NamedJSON<C, D>, Ctx>;
    fndef: LutFn<ast.FunctionDefinition<A, B>, ast.FunctionDefinition<C, D>, Ctx>;
    import: LutFn<ast.Import<A, B>, ast.Import<C, D>, Ctx>;
    note: LutFn<ast.Note<A, B>, ast.Note<C, D>, Ctx>;
    root: LutFn<ast.Root<A, B>, ast.Root<C, D>, Ctx>;
};
export declare const noOpLutFn: <A, B>(a: A, b: B) => [A, B];
export declare const astTypeNamesArray: readonly ["number", "binop", "unop", "ident", "fncall", "macrocall", "block", "listcomp", "point", "steprange", "list", "sumprodint", "derivative", "case", "actions", "memberaccess", "dnumber", "dstring", "dboolean", "dnull", "darray", "dobject", "ddesmoscript", "assignment", "namespace", "namedjson", "fndef", "import", "note", "root"];
export type ASTTypeName = (typeof astTypeNamesArray)[number];
export declare const astTypeNames: Set<"number" | "assignment" | "fndef" | "macrocall" | "binop" | "unop" | "ident" | "fncall" | "block" | "listcomp" | "point" | "steprange" | "list" | "sumprodint" | "derivative" | "case" | "actions" | "memberaccess" | "dnumber" | "dstring" | "dboolean" | "dnull" | "darray" | "dobject" | "ddesmoscript" | "namespace" | "namedjson" | "import" | "note" | "root">;
export declare function makeFixedOpLUT<A extends ast.URIS, Ctx, B extends ast.URIS, Names extends ASTTypeName>(includedASTTypeNames: readonly Names[], op: (c: ast.NodeTypes<A>[Names], d: Ctx) => [ast.NodeTypes<B, A>[Names], Ctx]): Pick<ASTLookupTable<A, A, B, A, Ctx>, Names>;
export declare function mapASTPreOrder<A extends ast.URIS, B extends ast.URIS, C, NodeType extends keyof ast.NodeTypes>(ast: ast.NodeTypes<A, A>[NodeType], lut: ASTLookupTable<A, A, B, A, C>, ctx: C): ast.NodeTypes<B, B>[NodeType];
export declare function liftMacroPromisesHelper(ast: any): Promise<any>;
export declare function liftMacroPromises<T extends keyof ast.NodeTypes<"macrosub" | "macrosubsync">>(node: ast.NodeTypes<"macrosub">[T]): Promise<ast.NodeTypes<"macrosubsync">[T]>;
export {};
